<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strength Training Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
      :root {
        /* Background colors - aligned with blog theme */
        --bg-primary: #212121;
        --bg-secondary: #2a2a2a;
        --bg-tertiary: #333333;
        --bg-hover: #3a3a3a;

        /* Text colors - aligned with blog theme */
        --text-primary: #dadada;
        --text-bright: #fff;
        --text-muted: #888;
        --text-muted-light: #aaa;
        --text-muted-dark: #666;

        /* Accent colors - aligned with blog theme */
        --accent-blue: #42a5f5;
        --accent-green: #4CAF50;
        --accent-red: #ef5350;
        --accent-yellow: #ffc107;
        --accent-gold: #ffd700;

        /* Lift-specific colors - slightly adjusted for cohesion */
        --lift-squat: #42a5f5;
        --lift-bench: #ef5350;
        --lift-deadlift: #4CAF50;
        --lift-ohp: #ffc107;

        /* Border colors */
        --border-primary: #3a3a3a;
        --border-secondary: #424242;
        --border-hover: #555;

        /* Spacing */
        --spacing-xs: 0.25rem;
        --spacing-sm: 0.5rem;
        --spacing-md: 1rem;
        --spacing-lg: 1.5rem;
        --spacing-xl: 2rem;
        --spacing-2xl: 4rem;

        /* Border radius */
        --radius-sm: 4px;
        --radius-md: 8px;
        --radius-lg: 20px;
      }

      /* Lift-specific card styles */
      .lift-card {
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-primary);
        border-left: 3px solid;
        padding: var(--spacing-lg);
        text-align: left;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .lift-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .lift-card-squat {
        border-left-color: var(--lift-squat);
      }

      .lift-card-bench {
        border-left-color: var(--lift-bench);
      }

      .lift-card-deadlift {
        border-left-color: var(--lift-deadlift);
      }

      .lift-card-ohp {
        border-left-color: var(--lift-ohp);
      }

      .lift-card h4 {
        margin: 0 0 var(--spacing-md) 0;
      }

      .lift-card-squat h4 {
        color: var(--lift-squat);
      }
      .lift-card-bench h4 {
        color: var(--lift-bench);
      }
      .lift-card-deadlift h4 {
        color: var(--lift-deadlift);
      }
      .lift-card-ohp h4 {
        color: var(--lift-ohp);
      }

      /* Utility classes */
      .text-xs {
        font-size: 0.65rem;
      }
      .text-sm {
        font-size: 0.75rem;
      }
      .text-base {
        font-size: 0.875rem;
      }
      .text-lg {
        font-size: 1rem;
      }
      .text-xl {
        font-size: 1.25rem;
      }
      .text-2xl {
        font-size: 1.5rem;
      }
      .text-3xl {
        font-size: 1.75rem;
      }

      .text-muted-color {
        color: var(--text-muted);
      }
      .text-muted-light-color {
        color: var(--text-muted-light);
      }
      .text-muted-dark-color {
        color: var(--text-muted-dark);
      }
      .text-primary-color {
        color: var(--text-primary);
      }
      .text-bright-color {
        color: var(--text-bright);
      }

      .text-upper {
        text-transform: uppercase;
      }
      .text-center {
        text-align: center;
      }
      .font-weight-600 {
        font-weight: 600;
      }
      .font-weight-700 {
        font-weight: 700;
      }

      .mb-0 {
        margin-bottom: 0;
      }
      .mb-xs {
        margin-bottom: var(--spacing-xs);
      }
      .mb-sm {
        margin-bottom: var(--spacing-sm);
      }
      .mb-md {
        margin-bottom: var(--spacing-md);
      }
      .mb-lg {
        margin-bottom: var(--spacing-lg);
      }
      .mb-xl {
        margin-bottom: var(--spacing-xl);
      }

      .mt-xs {
        margin-top: var(--spacing-xs);
      }
      .mt-sm {
        margin-top: var(--spacing-sm);
      }
      .mt-md {
        margin-top: var(--spacing-md);
      }
      .mt-lg {
        margin-top: var(--spacing-lg);
      }
      .mt-xl {
        margin-top: var(--spacing-xl);
      }
      .mt-2xl {
        margin-top: var(--spacing-2xl);
      }

      .p-md {
        padding: var(--spacing-md);
      }
      .p-lg {
        padding: var(--spacing-lg);
      }

      .flex {
        display: flex;
      }
      .flex-between {
        justify-content: space-between;
      }
      .flex-center {
        justify-content: center;
      }
      .align-center {
        align-items: center;
      }
      .gap-sm {
        gap: var(--spacing-sm);
      }
      .gap-md {
        gap: var(--spacing-md);
      }
      .gap-lg {
        gap: var(--spacing-lg);
      }

      .grid-2col {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-lg);
      }
      .grid-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--spacing-lg);
      }

      /* Additional grid variations */
      .grid-stats-compact {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
      }

      .grid-2col-even {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        text-align: center;
      }

      .bg-tertiary {
        background: var(--bg-tertiary);
      }
      .rounded-md {
        border-radius: var(--radius-md);
      }
      .rounded-sm {
        border-radius: var(--radius-sm);
      }

      .border-top {
        border-top: 1px solid var(--border-primary);
      }
      .border-bottom {
        border-bottom: 1px solid var(--border-primary);
      }

      .h-8 {
        height: 8px;
      }
      .overflow-hidden {
        overflow: hidden;
      }

      .level-badge {
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .pr-badge {
        display: inline-block;
        padding: 0.35rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-secondary);
      }

      .pr-badge.recent {
        background: rgba(81, 207, 102, 0.15);
        border-color: rgba(81, 207, 102, 0.3);
        color: #51cf66;
      }

      .pr-badge.moderate {
        background: rgba(255, 217, 61, 0.15);
        border-color: rgba(255, 217, 61, 0.3);
        color: #ffd93d;
      }

      .pr-badge.stale {
        background: rgba(239, 83, 80, 0.15);
        border-color: rgba(239, 83, 80, 0.3);
        color: #ef5350;
      }

      .strength-bar {
        position: relative;
        height: 12px;
        background: var(--bg-hover);
        border-radius: 6px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .strength-bar-fill {
        position: absolute;
        height: 100%;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: width 0.6s ease;
        position: relative;
        overflow: hidden;
      }

      .strength-bar-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
        border-radius: 6px;
      }

      .fun-fact-box {
        margin-top: 2rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        border-left: 3px solid var(--accent-blue);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans,
          Ubuntu, Cantarell, 'Helvetica Neue', Helvetica, Arial, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 16px;
        line-height: 1.7;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--spacing-xl);
      }

      header {
        text-align: center;
        padding: var(--spacing-xl) 0;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-primary);
        margin-bottom: var(--spacing-xl);
      }

      h1 {
        font-size: 2.75rem;
        font-weight: 700;
        letter-spacing: -0.015em;
        margin-bottom: var(--spacing-sm);
        color: var(--text-bright);
      }

      .tagline {
        font-size: 1rem;
        color: var(--text-muted-light);
        margin: 0;
      }

      nav {
        position: sticky;
        top: 0;
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-primary);
        padding: var(--spacing-md) 0;
        z-index: 100;
        margin-bottom: var(--spacing-xl);
        transition: box-shadow 0.3s ease;
      }

      nav.scrolled {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .nav-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 var(--spacing-xl);
        flex-wrap: wrap;
        gap: var(--spacing-md);
      }

      .nav-links {
        display: flex;
        gap: var(--spacing-lg);
        flex-wrap: wrap;
        list-style: none;
      }

      nav a {
        color: var(--text-muted);
        text-decoration: none;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: color 0.2s;
      }

      nav a:hover {
        color: var(--accent-blue);
      }

      nav a.active {
        color: var(--text-primary);
      }

      .nav-controls {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
      }

      .back-link {
        color: var(--text-muted-light);
        text-decoration: none;
        font-size: 0.875rem;
        transition: color 0.2s;
        display: flex;
        align-items: center;
        gap: 0.25rem;
      }

      .back-link:hover {
        color: var(--accent-blue);
      }

      .unit-toggle {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-secondary);
        color: var(--text-primary);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-lg);
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .unit-toggle:hover {
        background: var(--bg-hover);
        border-color: var(--border-hover);
      }

      .unit-toggle:focus {
        outline: 2px solid var(--accent-blue);
        outline-offset: 2px;
      }

      section {
        margin: var(--spacing-2xl) 0;
        padding: var(--spacing-2xl) 0;
        border-top: 1px solid var(--border-primary);
        position: relative;
      }

      section:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      section:nth-child(even) {
        background: linear-gradient(to bottom, transparent, rgba(42, 42, 42, 0.3) 10%, rgba(42, 42, 42, 0.3) 90%, transparent);
        margin-left: calc(var(--spacing-xl) * -1);
        margin-right: calc(var(--spacing-xl) * -1);
        padding-left: var(--spacing-xl);
        padding-right: var(--spacing-xl);
      }

      h2 {
        font-size: 1.75rem;
        font-weight: 600;
        margin: var(--spacing-2xl) 0 var(--spacing-lg);
        color: var(--text-bright);
        letter-spacing: -0.01em;
      }

      h3 {
        font-size: 1.35rem;
        font-weight: 600;
        margin: var(--spacing-xl) 0 var(--spacing-lg);
        color: var(--text-bright);
      }

      h4 {
        font-size: 1.1rem;
        font-weight: 600;
        margin: var(--spacing-lg) 0 var(--spacing-md);
        color: var(--text-primary);
      }

      .foreword {
        max-width: 800px;
        margin: 0 auto;
        font-size: 1rem;
        line-height: 1.8;
        color: var(--text-muted-light);
      }

      .summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--spacing-xl);
        margin: 3rem 0;
      }

      .stat-card {
        text-align: center;
        padding: var(--spacing-lg);
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-primary);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .stat-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .stat-number {
        font-size: 3rem;
        font-weight: 700;
        color: var(--text-bright);
        margin-bottom: var(--spacing-sm);
      }

      .stat-number.accent {
        color: var(--accent-blue);
      }

      .stat-number.accent-gold {
        color: var(--accent-gold);
      }

      .stat-number.accent-green {
        color: var(--accent-green);
      }

      .stat-label {
        font-size: 0.875rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .stat-sublabel {
        font-size: 0.75em;
        display: block;
        margin-top: 0.25rem;
      }

      .stat-number-compact {
        font-size: 2rem;
      }

      .section-title {
        margin-top: 0;
        margin-bottom: 1rem;
      }

      .grid-2col {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 2rem;
      }

      .chart-canvas {
        max-height: 350px;
      }

      /* Mini stat styles for inline replacement */
      .stat-mini {
        text-align: center;
      }

      .stat-mini-label {
        color: var(--text-muted-dark);
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: var(--spacing-xs);
      }

      .stat-mini-value {
        color: var(--text-primary);
        font-size: 1.5rem;
        font-weight: 700;
      }

      .stat-mini-value.large {
        font-size: 2rem;
      }

      .stat-mini-value.accent-blue {
        color: var(--lift-squat);
      }

      .stat-mini-value.accent-red {
        color: var(--lift-bench);
      }

      .stat-mini-value.accent-green {
        color: var(--lift-deadlift);
      }

      .stat-mini-value.accent-gold {
        color: var(--accent-gold);
      }

      .stat-mini-detail {
        color: var(--text-muted-dark);
        font-size: 0.75rem;
        margin-top: var(--spacing-xs);
      }

      /* Lift stats grid */
      .lift-stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 1.5rem;
        text-align: center;
        margin-bottom: 2rem;
      }

      .lift-stats-grid.big-three-stats {
        margin-bottom: 1.5rem;
      }

      /* Powerlifting total display */
      .total-header {
        margin-top: 0;
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .progress-indicator {
        margin-top: 1.5rem;
      }

      .progress-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
      }

      .progress-label {
        color: var(--text-muted);
      }

      .progress-value {
        color: var(--accent-blue);
        font-weight: 600;
      }

      /* Club milestone section */
      .club-milestones {
        margin-top: 2rem;
      }

      .club-milestones h4 {
        margin-bottom: 1rem;
        color: var(--text-muted);
      }

      .club-milestone {
        border-left: 3px solid;
        padding-left: 1rem;
        margin: 0.5rem 0;
      }

      .club-milestone-text {
        margin-left: 0.5rem;
        color: var(--text-muted-dark);
      }

      /* Plate milestone grid */
      .plate-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 2rem;
      }

      .plate-lift-section h4 {
        margin-bottom: 1rem;
      }

      .plate-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--border-primary);
      }

      .plate-item.unachieved {
        opacity: 0.4;
      }

      .plate-icon {
        font-size: 1.25rem;
      }

      .plate-label {
        flex: 1;
      }

      .plate-date {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      /* Progress bar styles */
      .progress-bar {
        background: var(--bg-tertiary);
        height: 16px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--border-primary);
      }

      .progress-fill {
        height: 100%;
        border-radius: 8px;
        transition: width 0.6s ease;
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .progress-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
      }

      .progress-fill.accent-blue {
        background: var(--accent-blue);
      }

      /* Milestone and PR row styles */
      .milestone {
        display: flex;
        align-items: center;
        gap: var(--spacing-lg);
        padding: var(--spacing-sm) 0;
        border-bottom: 1px solid var(--border-primary);
      }

      .milestone:last-child {
        border-bottom: none;
      }

      .milestone-date {
        min-width: 100px;
        color: var(--text-muted);
        font-size: 0.875rem;
        flex-shrink: 0;
      }

      .milestone-text {
        color: var(--text-primary);
        flex: 1;
      }

      .milestone-item {
        border-left: 3px solid;
        padding-left: var(--spacing-md);
        margin: var(--spacing-sm) 0;
      }

      .pr-row {
        display: flex;
        justify-content: space-between;
        padding: 0.35rem 0;
        border-bottom: 1px solid var(--border-primary);
      }

      .pr-label {
        color: var(--text-muted);
      }

      .pr-value {
        color: var(--text-primary);
        font-weight: 600;
      }

      .chart-container {
        margin: var(--spacing-xl) 0;
        background: var(--bg-secondary);
        padding: var(--spacing-xl);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-primary);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      svg {
        width: 100%;
        height: auto;
      }

      .heatmap-cell {
        cursor: pointer;
      }

      .heatmap-cell:hover {
        stroke: var(--text-bright);
        stroke-width: 2;
        transition: stroke 0.2s ease;
      }

      .tooltip {
        position: absolute;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-secondary);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-sm);
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 1000;
        display: none;
      }

      .notable-workout {
        background: var(--bg-secondary);
        padding: var(--spacing-md);
        margin: var(--spacing-sm) 0;
        border-radius: var(--radius-sm);
        border-left: 3px solid var(--accent-blue);
      }

      .notable-date {
        font-weight: 600;
        color: var(--accent-blue);
      }

      .milestone {
        display: flex;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--border-primary);
      }

      .milestone-date {
        min-width: 100px;
        color: var(--text-muted);
      }

      .milestone-text {
        color: var(--text-primary);
      }

      .program-card {
        background: var(--bg-secondary);
        padding: var(--spacing-lg);
        margin: var(--spacing-md) 0;
        border-radius: var(--radius-sm);
        border-left: 3px solid var(--text-muted);
      }

      .program-name {
        font-weight: 600;
        font-size: 1.125rem;
        margin-bottom: var(--spacing-sm);
      }

      .program-stats {
        display: flex;
        gap: var(--spacing-xl);
        margin-top: var(--spacing-sm);
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      .view-toggle {
        display: flex;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-md);
        justify-content: center;
      }

      .view-toggle button {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-secondary);
        color: var(--text-muted);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-sm);
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s;
      }

      .view-toggle button:hover {
        border-color: var(--border-hover);
        color: var(--text-primary);
      }

      .view-toggle button.active {
        background: var(--accent-blue);
        border-color: var(--accent-blue);
        color: var(--text-bright);
      }

      .view-toggle button:focus {
        outline: 2px solid var(--accent-blue);
        outline-offset: 2px;
      }

      /* General button focus states */
      button:focus-visible {
        outline: 2px solid var(--accent-blue);
        outline-offset: 2px;
      }

      /* Link focus states */
      a:focus-visible {
        outline: 2px solid var(--accent-blue);
        outline-offset: 2px;
        border-radius: 2px;
      }

      /* Loading state */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-primary);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .loading-overlay.hidden {
        opacity: 0;
        visibility: hidden;
      }

      .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid var(--bg-tertiary);
        border-top-color: var(--accent-blue);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .loading-text {
        margin-top: var(--spacing-lg);
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      @media (max-width: 768px) {
        .container {
          padding: var(--spacing-md);
        }

        h1 {
          font-size: 2rem;
        }

        h2 {
          font-size: 1.5rem;
        }

        h3 {
          font-size: 1.2rem;
        }

        .nav-container {
          flex-direction: column;
          align-items: stretch;
        }

        .nav-links {
          justify-content: center;
          order: 1;
          gap: var(--spacing-sm);
          font-size: 0.8rem;
        }

        .nav-controls {
          order: 2;
          justify-content: center;
          width: 100%;
          flex-wrap: wrap;
        }

        .summary-stats {
          grid-template-columns: 1fr;
        }

        .stat-number {
          font-size: 2rem;
        }

        /* Simplify grid layouts for mobile */
        .grid-2col {
          grid-template-columns: 1fr;
        }

        .grid-stats {
          grid-template-columns: 1fr;
        }

        .grid-stats-compact {
          grid-template-columns: repeat(2, 1fr);
        }

        .plate-grid {
          grid-template-columns: 1fr;
        }

        /* Reduce chart heights on mobile */
        .chart-canvas {
          max-height: 250px !important;
        }

        canvas {
          max-height: 250px !important;
        }

        /* Stack view toggle buttons vertically */
        .view-toggle {
          flex-wrap: wrap;
          gap: var(--spacing-xs);
        }

        .view-toggle button {
          flex: 1 1 auto;
          min-width: 80px;
        }

        /* Improve readability of stat mini values */
        .stat-mini-value {
          font-size: 1.25rem;
        }

        .stat-mini-value.large {
          font-size: 1.5rem;
        }

        /* Adjust lift card padding */
        .lift-card {
          padding: var(--spacing-md);
        }

        /* Reduce spacing in sections */
        section {
          margin: var(--spacing-lg) 0;
          padding: var(--spacing-lg) 0;
        }

        section:nth-child(even) {
          margin-left: calc(var(--spacing-md) * -1);
          margin-right: calc(var(--spacing-md) * -1);
          padding-left: var(--spacing-md);
          padding-right: var(--spacing-md);
        }

        /* Improve modal display on mobile */
        #keyboardShortcutsModal {
          max-width: 90% !important;
          padding: 1.5rem !important;
        }
      }

      /* Additional breakpoint for very small screens */
      @media (max-width: 480px) {
        h1 {
          font-size: 1.75rem;
        }

        .nav-links {
          font-size: 0.75rem;
        }

        .stat-number {
          font-size: 1.75rem;
        }

        .grid-stats-compact {
          grid-template-columns: 1fr;
        }

        .lift-stats-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 1rem;
        }
      }

      /* PR Timeline - Clean Card List */
      .pr-timeline-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
      }

      .pr-event-card {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        border-left: 4px solid var(--event-color);
        padding: var(--spacing-md);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .pr-event-card:hover {
        transform: translateX(4px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .pr-event-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--bg-tertiary);
        flex-shrink: 0;
      }

      .pr-event-icon {
        font-size: 1.25rem;
        color: var(--event-color);
      }

      .pr-event-peak .pr-event-indicator {
        background: color-mix(in srgb, var(--event-color) 20%, transparent);
      }

      .pr-event-club .pr-event-indicator {
        background: rgba(255, 215, 0, 0.15);
      }

      .pr-event-content {
        flex: 1;
        min-width: 0;
      }

      .pr-event-header {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: 4px;
      }

      .pr-event-lift {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--event-color);
      }

      .pr-event-type {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
        background: var(--bg-tertiary);
        padding: 2px 6px;
        border-radius: var(--radius-sm);
      }

      .pr-event-details {
        display: flex;
        align-items: baseline;
        gap: var(--spacing-sm);
      }

      .pr-event-milestone {
        font-size: 0.85rem;
        color: var(--text-muted-light);
      }

      .pr-event-weight {
        font-weight: 700;
        font-size: 1.1rem;
        color: var(--text-bright);
      }

      .pr-event-date {
        font-size: 0.75rem;
        color: var(--text-muted);
        text-align: right;
        white-space: nowrap;
        flex-shrink: 0;
      }

      @media (max-width: 600px) {
        .pr-event-card {
          flex-wrap: wrap;
          gap: var(--spacing-sm);
        }

        .pr-event-date {
          width: 100%;
          text-align: left;
          padding-left: calc(40px + var(--spacing-md));
          margin-top: -4px;
        }

        .pr-event-indicator {
          width: 32px;
          height: 32px;
        }

        .pr-event-icon {
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-spinner" role="status" aria-live="polite"></div>
      <div class="loading-text">Loading training data...</div>
    </div>

    <header>
      <div class="container">
        <h1>NO DAYS OFF</h1>
        <p class="tagline">
          A data-driven look at my strength training journey
        </p>
      </div>
    </header>

    <nav id="mainNav" role="navigation" aria-label="Dashboard navigation">
      <div class="nav-container">
        <ul class="nav-links">
          <li><a href="#overview" aria-label="Navigate to Overview section">Overview</a></li>
          <li><a href="#volume" aria-label="Navigate to Volume section">Volume</a></li>
          <li><a href="#strength" aria-label="Navigate to Strength section">Strength</a></li>
          <li><a href="#milestones" aria-label="Navigate to Milestones section">Milestones</a></li>
          <li><a href="#patterns" aria-label="Navigate to Patterns section">Patterns</a></li>
          <li><a href="#history" aria-label="Navigate to History section">History</a></li>
        </ul>
        <div class="nav-controls">
          <a href="/" class="back-link" aria-label="Return to blog homepage">‚Üê Back to Blog</a>
          <button class="unit-toggle" id="unitToggle" aria-label="Toggle between pounds and kilograms">lbs / kg</button>
        </div>
      </div>
    </nav>

    <div class="container">

      <section>
        <div class="foreword">
          <p>
            This dashboard chronicles my strength training journey from January
            2019 onwards. Every rep, every set, every workout‚Äîtracked, analyzed,
            and visualized. The data tells the story of consistency,
            progression, and the relentless pursuit of strength.
          </p>
        </div>
      </section>

      <section id="overview">
        <h2>Overview</h2>
        <div class="summary-stats" id="summaryStats">
          <!-- Generated dynamically -->
        </div>
        <div class="grid-stats-compact mt-xl" id="workoutStructureStats">
          <!-- Generated dynamically -->
        </div>
      </section>

      <section id="volume">
        <h2>Volume & Trends</h2>
        <div class="grid-stats-compact mb-xl" id="volumeHighlights">
          <!-- Generated dynamically -->
        </div>
        <div class="chart-container">
          <h3>Volume Over Time</h3>
          <div class="view-toggle" role="group" aria-label="Volume chart time period selector">
            <button data-view="weekly" aria-label="Show weekly volume data">Weekly</button>
            <button data-view="monthly" aria-label="Show monthly volume data">Monthly</button>
            <button data-view="yearly" aria-label="Show yearly volume data">Yearly</button>
            <button data-view="cumulative" aria-label="Show cumulative volume data">Cumulative</button>
          </div>
          <div id="stackedToggleContainer" class="view-toggle" style="margin-top: 0.5rem;">
            <button id="stackedToggle" aria-label="Toggle between stacked and overlaid chart view">üìä Show Stacked</button>
          </div>
          <canvas id="annualVolumeChart" style="max-height: 400px" role="img" aria-label="Volume over time chart"></canvas>
        </div>
        <div class="chart-container">
          <h3>Workout Calendar</h3>
          <div id="workoutHeatmap"></div>
        </div>
      </section>

      <section id="strength">
        <h2>Strength Progress</h2>
        <div class="chart-container" id="relativeStrengthSection">
          <!-- Generated dynamically - Relative Strength Metrics -->
        </div>
        <div id="bigThreeCharts">
          <!-- Generated dynamically -->
        </div>
      </section>

      <section id="milestones">
        <h2>Milestones & Achievements</h2>
        <div class="chart-container" style="margin-bottom: 2rem">
          <h3>üìÖ PR Timeline</h3>
          <p class="text-muted-color" style="margin-bottom: 1.5rem">
            Major milestones and peak performances throughout your training journey
          </p>
          <div id="prTimeline">
            <!-- Generated dynamically -->
          </div>
        </div>
        <div id="prsClubsContent">
          <!-- Generated dynamically -->
        </div>
        <div class="chart-container" style="margin-top: 2rem">
          <h3>üéØ Bar Travel Distance</h3>
          <div id="barTravelStats"></div>
        </div>
      </section>

      <section id="patterns">
        <h2>Patterns & Analysis</h2>
        <div class="chart-container">
          <h3>Volume by Day of Week</h3>
          <div id="dayOfWeekChart"></div>
        </div>
        <div class="chart-container">
          <h3>Exercises by Volume</h3>
          <div id="exerciseVolumeChart"></div>
        </div>
      </section>

      <section id="history">
        <h2>Training History</h2>
        <h3>Programs</h3>
        <div id="programsList">
          <!-- Generated dynamically -->
        </div>
        <h3 style="margin-top: 3rem">Notable Workouts</h3>
        <div id="notableWorkoutsList">
          <!-- Generated dynamically -->
        </div>
      </section>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      // Global state
      let trainingData = null;
      let currentUnit = localStorage.getItem('weightUnit') || 'lbs';
      let volumeView = localStorage.getItem('volumeView') || 'monthly';
      let volumeStacked = localStorage.getItem('volumeStacked') === 'true';

      // Load data and initialize dashboard
      async function init() {
        const loadingOverlay = document.getElementById('loadingOverlay');

        try {
          const response = await fetch(`training_data.json?v=${Date.now()}`);
          trainingData = await response.json();
          renderDashboard();
          setupUnitToggle();
          setupViewToggle();
          setupStackedToggle();

          // Hide loading overlay after content is rendered
          setTimeout(() => {
            loadingOverlay.classList.add('hidden');
          }, 300);
        } catch (error) {
          console.error('Error loading training data:', error);
          loadingOverlay.classList.add('hidden');
          document.querySelector('.container').innerHTML = `
                    <section style="text-align: center; padding: 4rem 2rem;">
                        <h2 style="color: #ff6b6b; margin-bottom: 1rem;">Unable to Load Data</h2>
                        <p style="color: var(--text-muted);">Please refresh the page to try again.</p>
                    </section>
                `;
        }
      }

      function setupUnitToggle() {
        const toggleButton = document.getElementById('unitToggle');
        updateToggleButton();

        toggleButton.addEventListener('click', () => {
          currentUnit = currentUnit === 'lbs' ? 'kg' : 'lbs';
          localStorage.setItem('weightUnit', currentUnit);
          updateToggleButton();
          renderDashboard();
        });
      }

      function updateToggleButton() {
        const toggleButton = document.getElementById('unitToggle');
        toggleButton.textContent =
          currentUnit === 'lbs' ? 'switch to kg' : 'switch to lbs';
      }

      function setupViewToggle() {
        const buttons = document.querySelectorAll('.view-toggle button[data-view]');
        const stackedContainer = document.getElementById('stackedToggleContainer');

        // Update active state and toggle stacked button visibility
        function updateActiveButton() {
          buttons.forEach((btn) => {
            btn.classList.toggle('active', btn.dataset.view === volumeView);
          });

          // Hide stacked toggle for cumulative view (stacking doesn't make sense for cumulative data)
          if (stackedContainer) {
            stackedContainer.style.display = volumeView === 'cumulative' ? 'none' : '';
          }
        }

        updateActiveButton();

        buttons.forEach((button) => {
          button.addEventListener('click', () => {
            volumeView = button.dataset.view;
            localStorage.setItem('volumeView', volumeView);
            updateActiveButton();
            renderAnnualVolumeChart();
          });
        });
      }

      function setupStackedToggle() {
        const button = document.getElementById('stackedToggle');
        if (!button) return;

        function updateButtonState() {
          button.classList.toggle('active', volumeStacked);
          button.textContent = volumeStacked ? 'üìä Show Overlaid' : 'üìä Show Stacked';
        }

        updateButtonState();

        button.addEventListener('click', () => {
          volumeStacked = !volumeStacked;
          localStorage.setItem('volumeStacked', volumeStacked);
          updateButtonState();
          renderAnnualVolumeChart();
        });
      }

      function getVolume(volumeLbs, volumeKg) {
        return currentUnit === 'lbs' ? volumeLbs : volumeKg;
      }

      function formatVolume(volumeLbs, volumeKg) {
        const volume = getVolume(volumeLbs, volumeKg);
        return `${volume.toLocaleString()} ${currentUnit}`;
      }

      function isoWeekToDate(weekString) {
        // Convert YYYY-Www format to date of Monday of that week
        const parts = weekString.match(/^(\d{4})-W(\d{2})$/);
        if (!parts) return weekString;

        const year = parseInt(parts[1]);
        const week = parseInt(parts[2]);

        // January 4th is always in week 1 (ISO 8601)
        const jan4 = new Date(year, 0, 4);
        const monday = new Date(jan4);
        monday.setDate(jan4.getDate() - (jan4.getDay() || 7) + 1);
        monday.setDate(monday.getDate() + (week - 1) * 7);

        return monday.toISOString().split('T')[0];
      }

      function createSVGElement(tag, attrs = {}) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        Object.entries(attrs).forEach(([key, value]) => {
          el.setAttribute(key, value);
        });
        return el;
      }

      function createSVGText(x, y, text, attrs = {}) {
        const el = createSVGElement('text', { x, y, ...attrs });
        el.textContent = text;
        return el;
      }

      function renderDashboard() {
        // Overview section
        renderSummaryStats();
        renderWorkoutStructure();

        // Volume & Trends section
        renderVolumeHighlights();
        renderAnnualVolumeChart();
        renderWorkoutHeatmap();

        // Strength Progress section
        renderRelativeStrength();
        renderBigThree();

        // Milestones & Achievements section
        renderPRTimeline();
        renderPRsAndClubs();
        renderBarTravel();

        // Patterns & Analysis section
        renderDayOfWeekChart();
        renderExerciseVolumeChart();

        // Training History section
        renderPrograms();
        renderNotableWorkouts();
      }

      function renderSummaryStats() {
        const { summary } = trainingData;
        const statsContainer = document.getElementById('summaryStats');

        const totalVolume = getVolume(
          summary.totalVolumeLbs,
          summary.totalVolumeKg,
        );
        const avgVolume = getVolume(
          summary.avgVolumePerWorkoutLbs,
          summary.avgVolumePerWorkoutKg,
        );
        const years = calculateYears(summary.firstWorkout, summary.lastWorkout);

        statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${summary.totalWorkouts}</div>
                    <div class="stat-label">Total Workouts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.totalTons.toLocaleString()}</div>
                    <div class="stat-label">Total Tons <span class="stat-sublabel">(${Math.round(totalVolume / 1000)}K ${currentUnit})</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${Math.round(summary.totalReps / 1000)}K</div>
                    <div class="stat-label">Total Reps</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${years}</div>
                    <div class="stat-label">Years Training</div>
                </div>
            `;
      }

      function calculateYears(startDate, endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        const years = (end - start) / (1000 * 60 * 60 * 24 * 365.25);
        return years.toFixed(1);
      }

      function renderVolumeHighlights() {
        const { summary } = trainingData;
        const container = document.getElementById('volumeHighlights');

        const avgVolume = getVolume(
          summary.avgVolumePerWorkoutLbs,
          summary.avgVolumePerWorkoutKg,
        );

        container.innerHTML = `
          <div class="stat-card">
            <div class="stat-number stat-number-compact">${
              summary.bestMonthEver
                ? (() => {
                    const [y, m] = summary.bestMonthEver.month.split('-');
                    const months = [
                      'Jan',
                      'Feb',
                      'Mar',
                      'Apr',
                      'May',
                      'Jun',
                      'Jul',
                      'Aug',
                      'Sep',
                      'Oct',
                      'Nov',
                      'Dec',
                    ];
                    return months[parseInt(m) - 1] + ' ' + y;
                  })()
                : '‚Äî'
            }</div>
            <div class="stat-label">Best Month <span class="stat-sublabel">${summary.bestMonthEver ? Math.round(getVolume(summary.bestMonthEver.volumeLbs, summary.bestMonthEver.volumeKg) / 1000) + 'K ' + currentUnit : ''}</span></div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${summary.bestYearEver ? summary.bestYearEver.year : '‚Äî'}</div>
            <div class="stat-label">Best Year <span class="stat-sublabel">${summary.bestYearEver ? Math.round(getVolume(summary.bestYearEver.volumeLbs, summary.bestYearEver.volumeKg) / 1000) + 'K ' + currentUnit : ''} ‚Ä¢ ${summary.bestYearEver ? summary.bestYearEver.workouts : ''} workouts</span></div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${summary.workoutsPerWeekAvg}</div>
            <div class="stat-label">Workouts/Week Avg</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${Math.round(avgVolume / 1000)}K</div>
            <div class="stat-label">Avg Volume/Workout (${currentUnit})</div>
          </div>
        `;
      }

      let annualVolumeChartInstance = null;
      let bigThreeChartInstances = {};
      let bodyWeightChartInstance = null;

      // Shared Chart.js Configuration
      const CHART_COLORS = {
        grid: '#3a3a3a',
        text: '#888',
        textBright: '#dadada',
        tooltipBg: '#2a2a2a',
        tooltipBorder: '#424242',
      };

      const CHART_DEFAULTS = {
        borderWidth: 2.5,
        pointRadius: 0,
        pointHoverRadius: 6,
        pointHoverBorderWidth: 2,
        tension: 0.4,
        hitRadius: 10,
      };

      const LIFT_CONFIG = {
        squat: { name: 'Squat', color: '#4a9eff', order: 0 },
        bench: { name: 'Bench Press', color: '#ff6b6b', order: 1 },
        deadlift: { name: 'Deadlift', color: '#51cf66', order: 2 },
        ohp: { name: 'Overhead Press', color: '#ffd93d', order: 3 },
      };

      const LIFT_ORDER = ['squat', 'bench', 'deadlift', 'ohp'];

      function getBaseChartOptions(overrides = {}) {
        return {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false,
              position: 'top',
              labels: {
                color: CHART_COLORS.textBright,
                padding: 15,
                font: { size: 12 },
                usePointStyle: true,
                pointStyle: 'line',
              },
              ...(overrides.legend || {}),
            },
            tooltip: {
              backgroundColor: CHART_COLORS.tooltipBg,
              titleColor: CHART_COLORS.textBright,
              bodyColor: CHART_COLORS.textBright,
              borderColor: CHART_COLORS.tooltipBorder,
              borderWidth: 1,
              titleFont: { size: 13, weight: '600' },
              bodyFont: { size: 12 },
              padding: 12,
              displayColors: false,
              ...(overrides.tooltip || {}),
            },
            ...(overrides.plugins || {}),
          },
          scales: {
            x: {
              grid: { color: CHART_COLORS.grid },
              ticks: {
                color: CHART_COLORS.text,
                font: { size: 11 },
                maxRotation: 45,
              },
              ...(overrides.x || {}),
            },
            y: {
              beginAtZero: false,
              grid: { color: CHART_COLORS.grid },
              ticks: {
                color: CHART_COLORS.text,
                font: { size: 11 },
              },
              ...(overrides.y || {}),
            },
          },
        };
      }

      function createLineDataset(label, data, color, overrides = {}) {
        return {
          label,
          data,
          borderColor: color,
          backgroundColor: color + '20',
          borderWidth: CHART_DEFAULTS.borderWidth,
          pointRadius: CHART_DEFAULTS.pointRadius,
          pointHoverRadius: CHART_DEFAULTS.pointHoverRadius,
          pointHoverBorderWidth: CHART_DEFAULTS.pointHoverBorderWidth,
          pointBackgroundColor: color,
          pointBorderColor: '#fff',
          hitRadius: CHART_DEFAULTS.hitRadius,
          tension: CHART_DEFAULTS.tension,
          fill: false,
          ...overrides,
        };
      }

      function renderAnnualVolumeChart() {
        const { volumeTimeSeries, bigThreeVolume } = trainingData;

        // Helper function to aggregate Big 3 volume data
        function aggregateBigThreeVolume(lift) {
          if (
            !bigThreeVolume ||
            !bigThreeVolume[lift] ||
            !bigThreeVolume[lift].dailyVolume
          ) {
            return [];
          }

          const dailyData = bigThreeVolume[lift].dailyVolume;

          if (volumeView === 'cumulative') {
            let cumulativeTotal = 0;
            return dailyData.map((d) => {
              cumulativeTotal += getVolume(d.volumeLbs, d.volumeKg);
              return { x: d.date, y: cumulativeTotal };
            });
          } else if (volumeView === 'weekly') {
            const weeklyData = {};
            dailyData.forEach((d) => {
              const date = new Date(d.date);
              const weekStart = new Date(date);
              weekStart.setDate(date.getDate() - date.getDay());
              const weekKey = weekStart.toISOString().split('T')[0];
              if (!weeklyData[weekKey]) {
                weeklyData[weekKey] = { volumeLbs: 0, volumeKg: 0 };
              }
              weeklyData[weekKey].volumeLbs += d.volumeLbs;
              weeklyData[weekKey].volumeKg += d.volumeKg;
            });
            return Object.entries(weeklyData).map(([date, vol]) => ({
              x: date,
              y: getVolume(vol.volumeLbs, vol.volumeKg),
            }));
          } else if (volumeView === 'monthly') {
            const monthlyData = {};
            dailyData.forEach((d) => {
              const monthKey = d.date.substring(0, 7);
              if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = { volumeLbs: 0, volumeKg: 0 };
              }
              monthlyData[monthKey].volumeLbs += d.volumeLbs;
              monthlyData[monthKey].volumeKg += d.volumeKg;
            });
            return Object.entries(monthlyData).map(([month, vol]) => ({
              x: month + '-01',
              y: getVolume(vol.volumeLbs, vol.volumeKg),
            }));
          } else if (volumeView === 'yearly') {
            const yearlyData = {};
            dailyData.forEach((d) => {
              const year = d.date.substring(0, 4);
              if (!yearlyData[year]) {
                yearlyData[year] = { volumeLbs: 0, volumeKg: 0 };
              }
              yearlyData[year].volumeLbs += d.volumeLbs;
              yearlyData[year].volumeKg += d.volumeKg;
            });
            return Object.entries(yearlyData).map(([year, vol]) => ({
              x: year,
              y: getVolume(vol.volumeLbs, vol.volumeKg),
            }));
          }
          return [];
        }

        // Select data based on view mode
        let data, chartData, label, timeUnit, displayFormat;

        if (volumeView === 'cumulative') {
          // Calculate cumulative volume from daily data
          data = volumeTimeSeries.daily;
          let cumulativeTotal = 0;
          chartData = data.map((d) => {
            cumulativeTotal += getVolume(d.volumeLbs, d.volumeKg);
            return {
              x: d.date,
              y: cumulativeTotal,
            };
          });
          label = `Total Volume (${currentUnit})`;
          timeUnit = 'month';
          displayFormat = { month: 'MMM yyyy' };
        } else if (volumeView === 'weekly') {
          data = volumeTimeSeries.weekly;
          chartData = data.map((d) => ({
            x: isoWeekToDate(d.week),
            y: getVolume(d.volumeLbs, d.volumeKg),
          }));
          label = `Total Volume (${currentUnit})`;
          timeUnit = 'month';
          displayFormat = { month: 'MMM yyyy' };
        } else if (volumeView === 'yearly') {
          data = volumeTimeSeries.yearly;
          chartData = data.map((d) => ({
            x: d.year.toString(),
            y: getVolume(d.volumeLbs, d.volumeKg),
          }));
          label = `Total Volume (${currentUnit})`;
          timeUnit = 'year';
          displayFormat = { year: 'yyyy' };
        } else {
          // monthly (default)
          data = volumeTimeSeries.monthly;
          chartData = data.map((d) => ({
            x: d.month + '-01',
            y: getVolume(d.volumeLbs, d.volumeKg),
          }));
          label = `Total Volume (${currentUnit})`;
          timeUnit = 'month';
          displayFormat = { month: 'MMM yyyy' };
        }

        if (data.length === 0) return;

        const canvas = document.getElementById('annualVolumeChart');
        const ctx = canvas.getContext('2d');

        // Destroy existing chart if it exists
        if (annualVolumeChartInstance) {
          annualVolumeChartInstance.destroy();
        }

        // Adjust visual settings based on view
        const isCumulative = volumeView === 'cumulative';
        const isYearly = volumeView === 'yearly';
        const useStacked = volumeStacked && !isCumulative;

        // Build datasets array with total volume + Big 3
        const datasets = [];

        // Only show total volume line when not in stacked mode
        if (!useStacked) {
          datasets.push(
            createLineDataset(label, chartData, '#888', {
              pointRadius: isYearly ? 6 : 0,
              pointHoverRadius: isYearly ? 8 : 6,
              fill: true,
              backgroundColor: '#88888833',
            }),
          );
        }

        // Add Big 3 datasets using centralized config
        const liftDatasets = [];
        LIFT_ORDER.forEach((lift) => {
          const config = LIFT_CONFIG[lift];
          const liftData = aggregateBigThreeVolume(lift);
          if (liftData.length > 0) {
            liftDatasets.push({ lift, config, data: liftData });
          }
        });

        // Normalize data points for stacking - all datasets need same x values
        if (useStacked && liftDatasets.length > 0) {
          // Collect all unique x values
          const allXValues = new Set();
          liftDatasets.forEach(({ data }) => {
            data.forEach(point => allXValues.add(point.x));
          });
          const sortedXValues = Array.from(allXValues).sort();

          // Normalize each dataset to have all x values (fill missing with 0)
          liftDatasets.forEach(({ data }) => {
            const dataMap = new Map(data.map(d => [d.x, d.y]));
            const normalized = sortedXValues.map(x => ({
              x: x,
              y: dataMap.get(x) || 0
            }));
            data.length = 0;
            data.push(...normalized);
          });
        }

        // Add normalized datasets to chart
        liftDatasets.forEach(({ config, data }) => {
          datasets.push(
            createLineDataset(config.name, data, config.color, {
              pointRadius: isYearly ? 4 : 0,
              pointHoverRadius: isYearly ? 6 : 4,
              fill: useStacked,
              stack: useStacked ? 'volume' : undefined,
              backgroundColor: useStacked ? config.color + '99' : config.color + '20',
            }),
          );
        });

        annualVolumeChartInstance = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: getBaseChartOptions({
            legend: {
              display: true,
              labels: {
                boxWidth: 12,
                boxHeight: 12,
                usePointStyle: false,
              },
              onClick: function(e, legendItem, legend) {
                const index = legendItem.datasetIndex;
                const chart = legend.chart;
                const meta = chart.getDatasetMeta(index);

                // Toggle visibility
                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                chart.update();
              },
            },
            tooltip: {
              mode: useStacked ? 'index' : 'nearest',
              intersect: false,
              callbacks: {
                title: function (context) {
                  if (volumeView === 'yearly') {
                    return context[0].label;
                  }
                  const date = new Date(context[0].parsed.x);
                  if (volumeView === 'weekly') {
                    return date.toLocaleDateString('en-US', {
                      month: 'short',
                      day: 'numeric',
                      year: 'numeric',
                    });
                  }
                  return date.toLocaleDateString('en-US', {
                    month: 'long',
                    year: 'numeric',
                  });
                },
                label: function (context) {
                  const volume = context.parsed.y;
                  const datasetLabel = context.dataset.label;
                  if (isCumulative) {
                    return `${datasetLabel}: ${(volume / 1000000).toFixed(2)}M ${currentUnit}`;
                  }
                  return `${datasetLabel}: ${(volume / 1000).toFixed(1)}K ${currentUnit}`;
                },
                footer: useStacked ? function(tooltipItems) {
                  let total = 0;
                  tooltipItems.forEach(item => {
                    total += item.parsed.y;
                  });
                  return `Total: ${(total / 1000).toFixed(1)}K ${currentUnit}`;
                } : undefined,
              },
            },
            x: {
              type: isYearly ? 'category' : 'time',
              stacked: useStacked,
              time: !isYearly
                ? {
                    unit: timeUnit,
                    displayFormats: displayFormat,
                  }
                : undefined,
            },
            y: {
              beginAtZero: true,
              stacked: useStacked,
              ticks: {
                callback: function (value) {
                  if (isCumulative && value >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                  }
                  return (value / 1000).toFixed(0) + 'K';
                },
              },
            },
          }),
        });
      }

      function renderWorkoutHeatmap() {
        const { workoutCalendar } = trainingData;
        const container = document.getElementById('workoutHeatmap');

        // Get date range
        const dates = Object.keys(workoutCalendar).sort();
        if (dates.length === 0) return;

        const startDate = new Date(dates[0]);
        const endDate = new Date(dates[dates.length - 1]);

        // Group dates by year
        const yearRanges = {};
        for (
          let year = startDate.getFullYear();
          year <= endDate.getFullYear();
          year++
        ) {
          const yearStart = new Date(year, 0, 1);
          const yearEnd = new Date(year, 11, 31);
          yearRanges[year] = {
            start: year === startDate.getFullYear() ? startDate : yearStart,
            end: year === endDate.getFullYear() ? endDate : yearEnd,
          };
        }

        // Calculate dimensions
        const cellSize = 12;
        const cellPadding = 2;
        const leftMargin = 60;
        const topMargin = 20;
        const rowHeight = (cellSize + cellPadding) * 7 + 50; // Extra space for year header
        const yearGap = 25;
        const width = leftMargin + (cellSize + cellPadding) * 53 + 20; // Max 53 weeks per year
        const years = Object.keys(yearRanges).length;
        const height = topMargin + (rowHeight + yearGap) * years + 60; // Extra space for legend

        // Calculate volume percentiles for color scaling
        const volumes = dates.map((d) =>
          getVolume(workoutCalendar[d].volumeLbs, workoutCalendar[d].volumeKg),
        );
        const sortedVolumes = [...volumes]
          .filter((v) => v > 0)
          .sort((a, b) => a - b);
        const getColorLevel = (volume) => {
          if (volume === 0) return 0;
          const percentile =
            sortedVolumes.indexOf(sortedVolumes.find((v) => v >= volume)) /
            sortedVolumes.length;
          if (percentile < 0.2) return 1;
          if (percentile < 0.4) return 2;
          if (percentile < 0.6) return 3;
          if (percentile < 0.8) return 4;
          return 5;
        };

        const colors = [
          '#262626', // No activity - lighter gray (more subtle)
          '#1b5e20', // Low activity - dark green
          '#2e7d32', // Medium-low activity
          '#43a047', // Medium activity
          '#4CAF50', // High activity - logo green
          '#66BB6A', // Very high activity - lighter green
        ];
        const monthNames = [
          'Jan',
          'Feb',
          'Mar',
          'Apr',
          'May',
          'Jun',
          'Jul',
          'Aug',
          'Sep',
          'Oct',
          'Nov',
          'Dec',
        ];

        const svg = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'svg',
        );
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        // Calculate workout counts per year
        const yearWorkoutCounts = {};
        Object.keys(workoutCalendar).forEach((dateStr) => {
          const year = dateStr.substring(0, 4);
          yearWorkoutCounts[year] =
            (yearWorkoutCounts[year] || 0) + workoutCalendar[dateStr].count;
        });

        // Render each year as a separate row
        let rowIndex = 0;
        for (const [year, range] of Object.entries(yearRanges)) {
          const rowY = topMargin + rowIndex * (rowHeight + yearGap);

          // Year header with workout count
          const yearLabel = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          yearLabel.setAttribute('x', leftMargin);
          yearLabel.setAttribute('y', rowY + 15);
          yearLabel.setAttribute('fill', '#dadada');
          yearLabel.setAttribute('font-size', '14');
          yearLabel.setAttribute('font-weight', '600');
          yearLabel.textContent = year;
          svg.appendChild(yearLabel);

          // Workout count for the year
          const workoutCount = yearWorkoutCounts[year] || 0;
          const countLabel = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          countLabel.setAttribute('x', leftMargin + 40);
          countLabel.setAttribute('y', rowY + 15);
          countLabel.setAttribute('fill', '#666');
          countLabel.setAttribute('font-size', '12');
          countLabel.textContent = `${workoutCount} workouts`;
          svg.appendChild(countLabel);

          // Separator line (except for first year)
          if (rowIndex > 0) {
            const line = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'line',
            );
            line.setAttribute('x1', leftMargin);
            line.setAttribute('y1', rowY - yearGap / 2);
            line.setAttribute('x2', width - 20);
            line.setAttribute('y2', rowY - yearGap / 2);
            line.setAttribute('stroke', '#3a3a3a');
            line.setAttribute('stroke-width', '1');
            svg.appendChild(line);
          }

          // Weekday labels for this row
          const days = ['S', 'M', 'T', 'W', 'T', 'F', 'S']; // Abbreviated
          days.forEach((day, i) => {
            const label = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'text',
            );
            label.setAttribute('x', 48);
            label.setAttribute('y', rowY + 42 + i * (cellSize + cellPadding));
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('fill', '#888');
            label.setAttribute('font-size', '10');
            label.textContent = day;
            svg.appendChild(label);
          });

          // Start from the Sunday before Jan 1st
          const yearStart = new Date(parseInt(year), 0, 1);
          const adjustedStart = new Date(yearStart);
          adjustedStart.setDate(
            adjustedStart.getDate() - adjustedStart.getDay(),
          );

          const yearEnd = new Date(parseInt(year), 11, 31);
          const currentDate = new Date(adjustedStart);
          let weekIndex = 0;
          let lastMonth = -1;

          while (currentDate <= yearEnd) {
            const dateStr = currentDate.toISOString().split('T')[0];
            const dayOfWeek = currentDate.getDay();
            const month = currentDate.getMonth();
            const dateYear = currentDate.getFullYear();

            const x = leftMargin + weekIndex * (cellSize + cellPadding);
            const y = rowY + 35 + dayOfWeek * (cellSize + cellPadding);

            // Only draw cells for dates within the year and data range
            if (currentDate >= range.start && currentDate <= range.end) {
              const data = workoutCalendar[dateStr];
              const volume = data
                ? getVolume(data.volumeLbs, data.volumeKg)
                : 0;
              const colorLevel = getColorLevel(volume);

              const rect = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'rect',
              );
              rect.setAttribute('x', x);
              rect.setAttribute('y', y);
              rect.setAttribute('width', cellSize);
              rect.setAttribute('height', cellSize);
              rect.setAttribute('fill', colors[colorLevel]);
              rect.setAttribute('rx', '2'); // Subtle rounded corners like GitHub
              rect.setAttribute('ry', '2');
              rect.setAttribute('class', 'heatmap-cell');
              rect.setAttribute('data-date', dateStr);
              rect.setAttribute('data-volume', volume.toFixed(0));
              rect.setAttribute('data-workouts', data ? data.count : 0);

              rect.addEventListener('mouseenter', (e) =>
                showTooltip(e, dateStr, volume, data ? data.count : 0),
              );
              rect.addEventListener('mouseleave', hideTooltip);

              svg.appendChild(rect);
            }

            // Add month labels (only on Sundays, when month changes, and for current year)
            if (
              dayOfWeek === 0 &&
              month !== lastMonth &&
              dateYear === parseInt(year)
            ) {
              const monthLabel = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'text',
              );
              monthLabel.setAttribute('x', x);
              monthLabel.setAttribute('y', rowY + 27);
              monthLabel.setAttribute('fill', '#aaa');
              monthLabel.setAttribute('font-size', '10');
              monthLabel.setAttribute('font-weight', '600');
              monthLabel.textContent = monthNames[month];
              svg.appendChild(monthLabel);
              lastMonth = month;
            }

            if (dayOfWeek === 6) weekIndex++;
            currentDate.setDate(currentDate.getDate() + 1);
          }

          rowIndex++;
        }

        // Add color legend at the bottom
        const legendY = height - 40;
        const legendX = width - 200;

        const legendLabel = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'text',
        );
        legendLabel.setAttribute('x', legendX - 40);
        legendLabel.setAttribute('y', legendY + 10);
        legendLabel.setAttribute('fill', '#888');
        legendLabel.setAttribute('font-size', '10');
        legendLabel.textContent = 'Less';
        svg.appendChild(legendLabel);

        // Legend boxes
        for (let i = 0; i < 5; i++) {
          const rect = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'rect',
          );
          rect.setAttribute('x', legendX + i * 16);
          rect.setAttribute('y', legendY);
          rect.setAttribute('width', cellSize);
          rect.setAttribute('height', cellSize);
          rect.setAttribute('fill', colors[i + 1]);
          rect.setAttribute('stroke', '#1a1a1a');
          rect.setAttribute('stroke-width', '1');
          svg.appendChild(rect);
        }

        const legendLabel2 = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'text',
        );
        legendLabel2.setAttribute('x', legendX + 85);
        legendLabel2.setAttribute('y', legendY + 10);
        legendLabel2.setAttribute('fill', '#888');
        legendLabel2.setAttribute('font-size', '10');
        legendLabel2.textContent = 'More';
        svg.appendChild(legendLabel2);

        container.innerHTML = '';
        container.appendChild(svg);
      }

      function showTooltip(e, date, volume, workouts) {
        const tooltip = document.getElementById('tooltip');
        const dateObj = new Date(date);
        const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long' });
        const formattedDate = dateObj.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });

        tooltip.style.display = 'block';
        tooltip.innerHTML = `
                <strong>${formattedDate}</strong> (${dayName})<br>
                ${workouts} workout${workouts !== 1 ? 's' : ''}<br>
                Volume: ${volume.toLocaleString()} ${currentUnit}
            `;
        tooltip.style.left = e.pageX + 10 + 'px';
        tooltip.style.top = e.pageY + 10 + 'px';
      }

      function hideTooltip() {
        document.getElementById('tooltip').style.display = 'none';
      }

      function renderBarTravel() {
        const { barTravel } = trainingData;
        const container = document.getElementById('barTravelStats');

        if (!barTravel) {
          container.innerHTML =
            '<p style="color: #888;">No bar travel data available</p>';
          return;
        }

        const { byLift, total, landmarks } = barTravel;
        const useMetric = currentUnit === 'kg';

        // Calculate max distance for bar chart scaling
        const liftDistances = Object.entries(byLift).map(([lift, data]) => ({
          lift,
          distance: useMetric ? data.totalKm : data.totalMiles,
          reps: data.totalReps,
          distancePerRep: data.distancePerRepInches,
        }));
        const maxDistance = Math.max(...liftDistances.map((d) => d.distance));

        // Lift names for display
        const liftNames = {
          squat: 'Squat',
          bench: 'Bench Press',
          deadlift: 'Deadlift',
          ohp: 'Overhead Press',
        };

        // Main stats display
        const totalDistance = useMetric ? total.km : total.miles;
        const distanceUnit = useMetric ? 'km' : 'miles';

        let html = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
            <div class="stat-card">
              <div class="stat-number stat-number-compact">${totalDistance.toFixed(1)}</div>
              <div class="stat-label">Total ${distanceUnit} traveled</div>
            </div>
            <div class="stat-card">
              <div class="stat-number stat-number-compact">${landmarks.everestClimbs.toFixed(1)}√ó</div>
              <div class="stat-label">Mt. Everest<span class="stat-sublabel">(29,032 ft / 8,849m)</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-number stat-number-compact">${landmarks.empireStateClimbs.toFixed(0)}√ó</div>
              <div class="stat-label">Empire State Building<span class="stat-sublabel">(1,454 ft / 443m)</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-number stat-number-compact">${landmarks.eiffelTowerClimbs.toFixed(0)}√ó</div>
              <div class="stat-label">Eiffel Tower<span class="stat-sublabel">(1,083 ft / 330m)</span></div>
            </div>
          </div>
        `;

        // Bar chart for distance by lift
        html +=
          '<h4 style="margin-bottom: 1rem; color: #aaa;">Distance by Lift</h4>';
        html +=
          '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">';

        // Sort by distance descending
        liftDistances.sort((a, b) => b.distance - a.distance);

        liftDistances.forEach(({ lift, distance, reps, distancePerRep }) => {
          const percentage = (distance / maxDistance) * 100;
          const name = liftNames[lift];

          html += `
            <div class="lift-card lift-card-${lift}">
              <h4>${name}</h4>
              <div style="font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem;">${distance.toFixed(2)} ${distanceUnit}</div>
              <div style="color: var(--text-muted); font-size: 0.875rem;">${reps.toLocaleString()} reps √ó ${distancePerRep}"</div>
              <div style="margin-top: 0.75rem; background: var(--bg-tertiary); height: 8px; border-radius: 4px; overflow: hidden;">
                <div style="background: var(--lift-${lift}); height: 100%; width: ${percentage}%; border-radius: 4px;"></div>
              </div>
            </div>
          `;
        });

        html += '</div>';

        // Fun facts section
        const totalFeet = total.feet;
        const marathons = totalFeet / (26.2 * 5280);

        html += `
          <div style="margin-top: 2rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-blue);">
            <div style="color: #aaa; font-size: 0.875rem; margin-bottom: 0.5rem;">üéØ Fun Perspective</div>
            <div style="color: #dadada;">
              If you laid all the bar travel end-to-end, you've moved the barbell
              <strong style="color: #ffd700;">${totalDistance.toFixed(1)} ${distanceUnit}</strong>
              ‚Äî equivalent to running <strong style="color: #4CAF50;">${marathons.toFixed(1)} marathons</strong>!
            </div>
          </div>
        `;

        container.innerHTML = html;
      }

      function renderRelativeStrength() {
        const { relativeStrength, bodyWeight } = trainingData;
        const container = document.getElementById('relativeStrengthSection');

        if (!relativeStrength) {
          container.innerHTML =
            '<p style="color: #888;">No relative strength data available</p>';
          return;
        }

        const benchmarks = relativeStrength.benchmarks || {};
        const totalMultiple = relativeStrength.totalMultiple || {};
        const wilks = relativeStrength.wilks || {};

        // Get body weight info
        const currentBW = bodyWeight?.current;
        const bwLbs = currentBW?.lbs || 0;
        const bwKg = currentBW?.kg || 0;
        const bwDisplay = currentBW
          ? currentUnit === 'lbs'
            ? `${bwLbs}`
            : `${bwKg}`
          : '‚Äî';

        // Calculate BMI (height = 6'0" = 72 inches = 1.83m)
        const heightInches = 72;
        const heightMeters = 1.83;
        const bmi =
          bwKg > 0 ? (bwKg / (heightMeters * heightMeters)).toFixed(1) : '‚Äî';

        // Check for stale data
        const stalePeriods = bodyWeight?.stalePeriods || [];
        const hasStaleData = stalePeriods.length > 0;

        let html = `<h3>üí™ Relative Strength</h3>`;

        // Determine Wilks level
        const wilksBenchmarks = wilks.benchmarks || {};
        let wilksLevel = 'Beginner';
        let wilksColor = '#888';
        if (wilks.best >= (wilksBenchmarks.worldClass || 500)) {
          wilksLevel = 'World Class';
          wilksColor = '#ffd700';
        } else if (wilks.best >= (wilksBenchmarks.elite || 450)) {
          wilksLevel = 'Elite';
          wilksColor = '#ffd700';
        } else if (wilks.best >= (wilksBenchmarks.advanced || 400)) {
          wilksLevel = 'Advanced';
          wilksColor = '#51cf66';
        } else if (wilks.best >= (wilksBenchmarks.intermediate || 300)) {
          wilksLevel = 'Intermediate';
          wilksColor = '#4a9eff';
        }

        // Vitals and combined total using stat cards
        html += `
          <div class="summary-stats" style="margin: 1.5rem 0;">
            <div class="stat-card">
              <div class="stat-number">${totalMultiple.best || 0}√ó</div>
              <div class="stat-label">S+B+D Total<span class="stat-sublabel">body weight</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-number" style="color: ${wilksColor};">${wilks.best || '‚Äî'}</div>
              <div class="stat-label">Wilks Score<span class="stat-sublabel">${wilksLevel}</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-number">${bwDisplay}</div>
              <div class="stat-label">Body Weight<span class="stat-sublabel">${currentUnit}</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-number">${bmi}</div>
              <div class="stat-label">BMI<span class="stat-sublabel">kg/m¬≤</span></div>
            </div>
          </div>
        `;

        // Radar chart for strength profile
        html += `
          <div class="chart-container" style="max-width: 700px; margin: 2rem auto;">
            <h4 class="text-muted-light-color mb-md text-center">Strength Profile</h4>
            <canvas id="strengthRadarChart" style="max-height: 500px;"></canvas>
          </div>
        `;

        // Individual lift details with benchmarks - 2x2 grid
        html += `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem;">`;

        const liftConfigs = [
          { key: 'squat', name: 'Squat', color: '#4a9eff' },
          { key: 'bench', name: 'Bench Press', color: '#ff6b6b' },
          { key: 'deadlift', name: 'Deadlift', color: '#51cf66' },
          { key: 'ohp', name: 'Overhead Press', color: '#ffd93d' },
        ];

        liftConfigs.forEach(({ key, name, color }) => {
          const liftData = relativeStrength[key];
          const liftBenchmarks = benchmarks[key] || {};

          if (!liftData) return;

          const best = liftData.best || {};
          const current = liftData.current || {};

          // Determine strength level based on best multiple
          const bestMult = best.multiple || 0;
          let level = 'Beginner';
          let levelColor = '#888';
          if (bestMult >= (liftBenchmarks.elite || 999)) {
            level = 'Elite';
            levelColor = '#ffd700';
          } else if (bestMult >= (liftBenchmarks.advanced || 999)) {
            level = 'Advanced';
            levelColor = '#51cf66';
          } else if (bestMult >= (liftBenchmarks.intermediate || 999)) {
            level = 'Intermediate';
            levelColor = '#4a9eff';
          }

          const bestLift = currentUnit === 'lbs' ? best.liftLbs : best.liftKg;
          const currentLift =
            currentUnit === 'lbs' ? current.liftLbs : current.liftKg;

          html += `
            <div class="lift-card lift-card-${key}">
              <div class="flex flex-between align-center mb-md">
                <h4 class="mb-0">${name}</h4>
                <span class="level-badge" style="background: ${levelColor}22; color: ${levelColor};">${level}</span>
              </div>
              <div class="grid-2col-even">
                <div>
                  <div class="text-muted-dark-color text-xs text-upper">Best</div>
                  <div class="text-primary-color text-xl font-weight-600">${best.multiple || '‚Äî'}√ó</div>
                  <div class="text-muted-color text-sm">${bestLift ? Math.round(bestLift) + ' ' + currentUnit : '‚Äî'}</div>
                </div>
                <div>
                  <div class="text-muted-dark-color text-xs text-upper">Current</div>
                  <div class="text-muted-light-color text-xl font-weight-600">${current.multiple || '‚Äî'}√ó</div>
                  <div class="text-muted-color text-sm">${currentLift ? Math.round(currentLift) + ' ' + currentUnit : '‚Äî'}</div>
                </div>
              </div>
              <div class="mt-md border-top" style="padding-top: 0.75rem;">
                <div class="flex flex-between text-xs text-muted-dark-color mb-xs">
                  <span>Beginner</span>
                  <span>Intermediate</span>
                  <span>Advanced</span>
                  <span>Elite</span>
                </div>
                <div class="strength-bar">
                  ${(() => {
                    const maxBench = liftBenchmarks.elite || 2.5;
                    const pct = Math.min((bestMult / maxBench) * 100, 100);
                    return `<div class="strength-bar-fill" style="width: ${pct}%; background: ${color};"></div>`;
                  })()}
                </div>
                <div class="flex flex-between text-xs mt-xs" style="color: #555;">
                  <span>${liftBenchmarks.beginner || 0}√ó</span>
                  <span>${liftBenchmarks.intermediate || 0}√ó</span>
                  <span>${liftBenchmarks.advanced || 0}√ó</span>
                  <span>${liftBenchmarks.elite || 0}√ó</span>
                </div>
              </div>
            </div>
          `;
        });

        html += `</div>`;

        // Body Weight Timeline Chart
        html += `
          <div class="mt-2xl">
            <h4 class="text-muted-light-color mb-md">üìà Body Weight Timeline</h4>
            ${hasStaleData ? '<div style="color: #cca300; font-size: 0.8rem; margin-bottom: 0.75rem;">‚ö†Ô∏è Note: Body weight data contains periods without updates</div>' : ''}
            <canvas id="bodyWeightChart" style="max-height: 200px;"></canvas>
          </div>
        `;

        container.innerHTML = html;

        // Render charts after DOM update
        setTimeout(() => {
          renderStrengthRadarChart();
          renderBodyWeightChart();
        }, 0);
      }

      let strengthRadarChartInstance = null;

      function renderStrengthRadarChart() {
        const { relativeStrength } = trainingData;
        const canvas = document.getElementById('strengthRadarChart');
        if (!canvas || !relativeStrength) return;

        // Destroy existing chart if it exists
        if (strengthRadarChartInstance) {
          strengthRadarChartInstance.destroy();
        }

        const ctx = canvas.getContext('2d');

        // Extract data for each lift
        const lifts = ['squat', 'bench', 'deadlift', 'ohp'];
        const liftLabels = ['Squat', 'Bench', 'Deadlift', 'OHP'];

        const bestData = lifts.map(lift => relativeStrength[lift]?.best?.multiple || 0);
        const currentData = lifts.map(lift => relativeStrength[lift]?.current?.multiple || 0);

        // Get max value for better scaling (add 20% padding)
        const maxMultiple = Math.max(...bestData, 3);
        const suggestedMax = Math.ceil(maxMultiple * 1.2 * 2) / 2; // Round to nearest 0.5

        strengthRadarChartInstance = new Chart(ctx, {
          type: 'radar',
          data: {
            labels: liftLabels,
            datasets: [
              {
                label: 'Best',
                data: bestData,
                borderColor: '#ffd700',
                backgroundColor: '#ffd70033',
                pointBackgroundColor: '#ffd700',
                pointBorderColor: '#fff',
                pointHoverRadius: 7,
                pointRadius: 5,
                borderWidth: 3,
              },
              {
                label: 'Current',
                data: currentData,
                borderColor: '#4a9eff',
                backgroundColor: '#4a9eff22',
                pointBackgroundColor: '#4a9eff',
                pointBorderColor: '#fff',
                pointHoverRadius: 7,
                pointRadius: 5,
                borderWidth: 3,
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: {
                  color: CHART_COLORS.textBright,
                  padding: 20,
                  font: { size: 14 },
                  usePointStyle: true,
                }
              },
              tooltip: {
                backgroundColor: CHART_COLORS.tooltipBg,
                titleColor: CHART_COLORS.textBright,
                bodyColor: CHART_COLORS.textBright,
                borderColor: CHART_COLORS.tooltipBorder,
                borderWidth: 1,
                padding: 12,
                titleFont: { size: 14 },
                bodyFont: { size: 13 },
                callbacks: {
                  label: function(context) {
                    return `${context.dataset.label}: ${context.parsed.r.toFixed(2)}√ó BW`;
                  }
                }
              }
            },
            scales: {
              r: {
                beginAtZero: true,
                suggestedMax: suggestedMax,
                ticks: {
                  color: CHART_COLORS.text,
                  backdropColor: 'transparent',
                  stepSize: 0.5,
                  font: { size: 12 },
                  callback: function(value) {
                    return value.toFixed(1) + '√ó';
                  }
                },
                grid: {
                  color: CHART_COLORS.grid
                },
                pointLabels: {
                  color: CHART_COLORS.textBright,
                  font: { size: 15, weight: '600' },
                  padding: 8
                }
              }
            }
          }
        });
      }

      function renderBodyWeightChart() {
        const { bodyWeight } = trainingData;
        const canvas = document.getElementById('bodyWeightChart');
        if (
          !canvas ||
          !bodyWeight ||
          !bodyWeight.monthlyTimeline ||
          bodyWeight.monthlyTimeline.length === 0
        )
          return;

        // Destroy existing chart if it exists
        if (bodyWeightChartInstance) {
          bodyWeightChartInstance.destroy();
        }

        const ctx = canvas.getContext('2d');
        const timeline = bodyWeight.monthlyTimeline;

        // Prepare data
        const avgData = timeline.map((d) => ({
          x: d.month + '-15',
          y: currentUnit === 'lbs' ? d.avgLbs : d.avgKg,
        }));

        // Min/max range for shaded area
        const rangeData = timeline.map((d) => ({
          x: d.month + '-15',
          min: currentUnit === 'lbs' ? d.minLbs : d.minKg,
          max: currentUnit === 'lbs' ? d.maxLbs : d.maxKg,
        }));

        const datasets = [
          // Shaded range (min to max)
          {
            label: 'Range',
            data: rangeData.map((d) => ({ x: d.x, y: [d.min, d.max] })),
            backgroundColor: '#4a9eff15',
            borderColor: 'transparent',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            // Use custom parsing for range
            parsing: false,
            normalized: true,
          },
          // Upper bound line (for fill reference)
          {
            label: 'Max',
            data: rangeData.map((d) => ({ x: d.x, y: d.max })),
            borderColor: '#4a9eff33',
            backgroundColor: '#4a9eff15',
            borderWidth: 1,
            pointRadius: 0,
            tension: 0.4,
            fill: '+1',
          },
          // Lower bound line
          {
            label: 'Min',
            data: rangeData.map((d) => ({ x: d.x, y: d.min })),
            borderColor: '#4a9eff33',
            borderWidth: 1,
            pointRadius: 0,
            tension: 0.4,
            fill: false,
          },
          // Average line (main)
          createLineDataset('Body Weight', avgData, '#4a9eff', {
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 4,
            fill: false,
          }),
        ];

        bodyWeightChartInstance = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: getBaseChartOptions({
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: function (context) {
                  const date = new Date(context[0].parsed.x);
                  return date.toLocaleDateString('en-US', {
                    month: 'long',
                    year: 'numeric',
                  });
                },
                label: function (context) {
                  if (context.dataset.label === 'Body Weight') {
                    const value = context.parsed.y;
                    // Find the corresponding range data
                    const idx = context.dataIndex;
                    const range = rangeData[idx];
                    if (range) {
                      return [
                        `Avg: ${value.toFixed(1)} ${currentUnit}`,
                        `Range: ${range.min.toFixed(1)} - ${range.max.toFixed(1)} ${currentUnit}`,
                      ];
                    }
                    return `${value.toFixed(1)} ${currentUnit}`;
                  }
                  return null;
                },
                filter: function (tooltipItem) {
                  return tooltipItem.dataset.label === 'Body Weight';
                },
              },
            },
            x: {
              type: 'time',
              time: {
                unit: 'month',
                displayFormats: { month: 'MMM yyyy' },
              },
              ticks: {
                maxTicksLimit: 12,
              },
            },
            y: {
              ticks: {
                callback: function (value) {
                  return value + ' ' + currentUnit;
                },
              },
            },
          }),
        });
      }

      function renderBigThree() {
        const { bigThreeE1RM, daysSinceLastPR } = trainingData;
        const container = document.getElementById('bigThreeCharts');
        container.innerHTML = '';

        if (!bigThreeE1RM || Object.keys(bigThreeE1RM).length === 0) {
          container.innerHTML =
            '<p style="color: #888;">No Big 3 data available</p>';
          return;
        }

        LIFT_ORDER.forEach((lift) => {
          const config = LIFT_CONFIG[lift];
          const hasE1RM =
            bigThreeE1RM &&
            bigThreeE1RM[lift] &&
            bigThreeE1RM[lift].e1rmHistory &&
            bigThreeE1RM[lift].e1rmHistory.length > 0;

          if (!hasE1RM) return;

          const e1rmData = bigThreeE1RM[lift];
          const daysSince =
            daysSinceLastPR && daysSinceLastPR[lift] !== null
              ? daysSinceLastPR[lift]
              : null;

          const chartDiv = document.createElement('div');
          chartDiv.className = `chart-container lift-card lift-card-${lift}`;

          const title = document.createElement('h4');
          title.textContent = config.name;
          chartDiv.appendChild(title);

          // Show key stats
          const stats = document.createElement('div');
          stats.className = 'lift-stats-grid big-three-stats';

          if (hasE1RM) {
            const history = e1rmData.e1rmHistory;
            const latest = history[history.length - 1];
            const peak = history.reduce((max, point) =>
              getVolume(point.e1rmLbs, point.e1rmKg) >
              getVolume(max.e1rmLbs, max.e1rmKg)
                ? point
                : max,
            );
            const first = history[0];

            const currentE1RM = Math.round(
              getVolume(latest.e1rmLbs, latest.e1rmKg),
            );
            const peakE1RM = Math.round(getVolume(peak.e1rmLbs, peak.e1rmKg));
            const startE1RM = Math.round(
              getVolume(first.e1rmLbs, first.e1rmKg),
            );
            const totalGain = currentE1RM - startE1RM;
            const gainPercent = ((totalGain / startE1RM) * 100).toFixed(0);

            // Days since last PR with color coding and badge styling
            let daysSinceHTML = '';
            if (daysSince !== null) {
              const badgeClass =
                daysSince < 30
                  ? 'recent'
                  : daysSince < 90
                    ? 'moderate'
                    : 'stale';
              const label =
                daysSince === 0
                  ? 'PR Today!'
                  : daysSince === 1
                    ? '1 day ago'
                    : `${daysSince} days ago`;
              daysSinceHTML = `
                <div style="text-align: center;">
                  <div class="stat-mini-label">Last PR</div>
                  <div style="margin-top: 0.5rem;">
                    <span class="pr-badge ${badgeClass}">${label}</span>
                  </div>
                </div>
              `;
            }

            stats.innerHTML = `
                        <div>
                            <div class="stat-mini-label">Starting e1RM</div>
                            <div class="stat-mini-value">${startE1RM} ${currentUnit}</div>
                            <div class="stat-mini-detail">${new Date(first.date).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</div>
                        </div>
                        <div>
                            <div class="stat-mini-label">Current e1RM</div>
                            <div class="stat-mini-value">${currentE1RM} ${currentUnit}</div>
                            <div class="stat-mini-detail">${new Date(latest.date).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</div>
                        </div>
                        <div>
                            <div class="stat-mini-label">Peak e1RM</div>
                            <div class="stat-mini-value">${peakE1RM} ${currentUnit}</div>
                            <div class="stat-mini-detail">${new Date(peak.date).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</div>
                        </div>
                        <div>
                            <div class="stat-mini-label">Total Gain</div>
                            <div class="stat-mini-value accent-green">+${totalGain} ${currentUnit}</div>
                            <div class="stat-mini-detail" style="color: #51cf66;">+${gainPercent}%</div>
                        </div>
                        ${daysSinceHTML}
                    `;
          }
          chartDiv.appendChild(stats);

          // Create canvas for Chart.js
          const canvas = document.createElement('canvas');
          canvas.id = `${lift}Chart`;
          canvas.className = 'chart-canvas';
          chartDiv.appendChild(canvas);

          container.appendChild(chartDiv);

          // Render chart after DOM update
          setTimeout(
            () =>
              renderBigThreeChart(
                lift,
                e1rmData.e1rmHistory || [],
                config.color,
              ),
            0,
          );
        });

        if (container.children.length === 0) {
          container.innerHTML =
            '<p style="color: #888;">No Big 3 data available</p>';
        }
      }

      function renderBigThreeChart(lift, e1rmHistory, color) {
        const canvas = document.getElementById(`${lift}Chart`);
        if (!canvas) return;

        // Destroy existing chart if it exists
        if (bigThreeChartInstances[lift]) {
          bigThreeChartInstances[lift].destroy();
        }

        const ctx = canvas.getContext('2d');
        const datasets = [];

        // Get PRs from allTimePRs
        const allTimePRs = trainingData.allTimePRs;
        const liftPRs =
          allTimePRs && allTimePRs[lift] && allTimePRs[lift].repPRs
            ? allTimePRs[lift].repPRs
            : {};

        // Show e1RM progression
        if (e1rmHistory && e1rmHistory.length > 0) {
          const e1rmData = e1rmHistory.map((point) => ({
            x: point.date,
            y: getVolume(point.e1rmLbs, point.e1rmKg),
            actualWeight: getVolume(
              point.actualWeightLbs,
              point.actualWeightKg,
            ),
            reps: point.reps,
          }));

          datasets.push(
            createLineDataset('Estimated 1RM', e1rmData, color, {
              backgroundColor: color + '15',
              fill: true,
            }),
          );
        }

        // Add actual PR markers from allTimePRs (show max weight for key rep ranges)
        if (Object.keys(liftPRs).length > 0) {
          // Only show PRs for key rep ranges (1, 3, 5, 8, 10)
          const keyRepRanges = [1, 3, 5, 8, 10];
          const prData = [];

          keyRepRanges.forEach((reps) => {
            if (liftPRs[reps]) {
              // Find the date when this PR was achieved from e1rmHistory
              const prEntry = e1rmHistory.find(
                (entry) =>
                  entry.reps === reps &&
                  Math.abs(
                    getVolume(entry.actualWeightLbs, entry.actualWeightKg) -
                      getVolume(
                        liftPRs[reps].weightLbs,
                        liftPRs[reps].weightKg,
                      ),
                  ) < 0.1,
              );

              if (prEntry) {
                prData.push({
                  x: prEntry.date,
                  y: getVolume(liftPRs[reps].weightLbs, liftPRs[reps].weightKg),
                  reps: reps,
                  isPR: true,
                });
              }
            }
          });

          if (prData.length > 0) {
            datasets.push({
              label: 'Key PRs',
              data: prData,
              type: 'scatter',
              backgroundColor: '#ffd700',
              borderColor: '#fff',
              borderWidth: 2,
              pointRadius: 8,
              pointHoverRadius: 10,
              pointStyle: 'circle',
              showLine: false,
              order: 0,
            });
          }
        }

        // Plate milestones for reference lines (in lbs, convert if kg)
        const plateMilestonesLbs = [135, 225, 315, 405, 495];
        const plateMilestonesKg = [60, 100, 140, 180, 220];
        const plateMilestones =
          currentUnit === 'lbs' ? plateMilestonesLbs : plateMilestonesKg;
        const plateLabels =
          currentUnit === 'lbs'
            ? ['1 plate', '2 plates', '3 plates', '4 plates', '5 plates']
            : ['60kg', '100kg', '140kg', '180kg', '220kg'];

        // Get y-axis range from data to filter relevant milestones
        const yValues = e1rmHistory.map((p) => getVolume(p.e1rmLbs, p.e1rmKg));
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);
        const yPadding = (maxY - minY) * 0.1;

        // Create annotation lines for plate milestones within data range
        const annotations = {};
        plateMilestones.forEach((weight, i) => {
          if (weight >= minY - yPadding && weight <= maxY + yPadding) {
            annotations[`plate${i}`] = {
              type: 'line',
              yMin: weight,
              yMax: weight,
              borderColor: '#ffffff22',
              borderWidth: 1,
              borderDash: [5, 5],
              label: {
                display: true,
                content: plateLabels[i],
                position: 'end',
                backgroundColor: 'transparent',
                color: '#666',
                font: { size: 10 },
              },
            };
          }
        });

        bigThreeChartInstances[lift] = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: getBaseChartOptions({
            plugins: {
              annotation: {
                annotations: annotations,
              },
            },
            tooltip: {
              callbacks: {
                title: function (context) {
                  const date = new Date(context[0].parsed.x);
                  return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                  });
                },
                label: function (context) {
                  const value = context.parsed.y;
                  if (context.raw.isPR) {
                    return `üèÜ PR: ${value} ${currentUnit} √ó ${context.raw.reps} reps`;
                  }
                  return `Estimated 1RM: ${value} ${currentUnit}`;
                },
                afterLabel: function (context) {
                  if (context.raw.actualWeight && !context.raw.isPR) {
                    return `From: ${context.raw.actualWeight} ${currentUnit} √ó ${context.raw.reps} reps`;
                  }
                  return '';
                },
              },
            },
            x: {
              type: 'time',
              time: {
                unit: 'month',
                displayFormats: { month: 'MMM yyyy' },
              },
            },
            y: {
              ticks: {
                callback: function (value) {
                  return value + ' ' + currentUnit;
                },
              },
            },
          }),
        });
      }

      function renderWorkoutStructure() {
        const { summary } = trainingData;
        const container = document.getElementById('workoutStructureStats');

        container.innerHTML = `
          <div class="stat-card">
            <div class="stat-number">${summary.avgSetsPerWorkout}</div>
            <div class="stat-label">Avg Sets/Workout</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${summary.avgWorkoutDuration}</div>
            <div class="stat-label">Avg Duration (min)</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${summary.totalHours}</div>
            <div class="stat-label">Total Hours</div>
          </div>
        `;
      }

      function renderExerciseVolumeChart() {
        const { exerciseProgress } = trainingData;
        const container = document.getElementById('exerciseVolumeChart');

        // Sort exercises by volume and take top 15
        const exercises = Object.entries(exerciseProgress)
          .map(([name, data]) => ({
            name,
            volume: getVolume(data.totalVolumeLbs, data.totalVolumeKg),
          }))
          .sort((a, b) => b.volume - a.volume)
          .slice(0, 15);

        if (exercises.length === 0) return;

        // Calculate total volume for percentage
        const totalVolume = exercises.reduce((sum, e) => sum + e.volume, 0);

        // Define colors for Big 4 lifts
        const liftColors = {
          'Squat': '#4a9eff',
          'Bench Press': '#ff6b6b',
          'Deadlift': '#51cf66',
          'Overhead Press': '#ffd93d'
        };

        const width = container.offsetWidth;
        const height = exercises.length * 35 + 60;
        const padding = { top: 20, right: 150, bottom: 40, left: 200 };

        const maxVolume = Math.max(...exercises.map((e) => e.volume));

        const svg = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'svg',
        );
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        exercises.forEach((exercise, i) => {
          const y = padding.top + i * 35;
          const barWidth =
            (exercise.volume / maxVolume) *
            (width - padding.left - padding.right);
          const percentage = ((exercise.volume / totalVolume) * 100).toFixed(1);

          // Determine bar color (use lift-specific color if it's a Big 4 lift)
          const barColor = liftColors[exercise.name] || '#4a9eff';

          // Bar with rounded corners
          const rect = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'rect',
          );
          rect.setAttribute('x', padding.left);
          rect.setAttribute('y', y);
          rect.setAttribute('width', 0); // Start with 0 for animation
          rect.setAttribute('height', 25);
          rect.setAttribute('fill', barColor);
          rect.setAttribute('rx', '3');
          rect.setAttribute('ry', '3');
          rect.style.opacity = '0.9';
          rect.style.transition = 'opacity 0.2s';

          // Animate bar growth
          const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
          animate.setAttribute('attributeName', 'width');
          animate.setAttribute('from', '0');
          animate.setAttribute('to', barWidth);
          animate.setAttribute('begin', `${i * 0.05}s`);
          animate.setAttribute('dur', '0.6s');
          animate.setAttribute('fill', 'freeze');
          rect.appendChild(animate);

          // Add hover effect
          rect.addEventListener('mouseenter', () => {
            rect.style.opacity = '1';
            rect.style.filter = 'brightness(1.1)';
          });
          rect.addEventListener('mouseleave', () => {
            rect.style.opacity = '0.9';
            rect.style.filter = 'none';
          });

          svg.appendChild(rect);

          // Exercise name with color indicator for Big 4
          const label = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          label.setAttribute('x', padding.left - 10);
          label.setAttribute('y', y + 17);
          label.setAttribute('text-anchor', 'end');
          label.setAttribute('fill', liftColors[exercise.name] ? barColor : '#dadada');
          label.setAttribute('font-size', '12');
          label.setAttribute('font-weight', liftColors[exercise.name] ? '600' : 'normal');
          label.textContent = exercise.name;
          svg.appendChild(label);

          // Volume label with percentage
          const volumeLabel = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          volumeLabel.setAttribute('x', padding.left + barWidth + 10);
          volumeLabel.setAttribute('y', y + 17);
          volumeLabel.setAttribute('fill', '#aaa');
          volumeLabel.setAttribute('font-size', '12');
          volumeLabel.textContent = `${Math.round(exercise.volume / 1000)}K`;
          svg.appendChild(volumeLabel);

          // Percentage label
          const percentLabel = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          percentLabel.setAttribute('x', padding.left + barWidth + 50);
          percentLabel.setAttribute('y', y + 17);
          percentLabel.setAttribute('fill', '#666');
          percentLabel.setAttribute('font-size', '11');
          percentLabel.textContent = `${percentage}%`;
          svg.appendChild(percentLabel);
        });

        container.innerHTML = '';
        container.appendChild(svg);
      }

      function renderPowerliftingTotals() {
        const { powerliftingTotals, milestones } = trainingData;
        if (!powerliftingTotals || !powerliftingTotals.current) return '';

        let html = '';
        const current = powerliftingTotals.current;
        const peak = powerliftingTotals.peak;
        const clubs = powerliftingTotals.clubMilestones || {};

        const totalValue =
          currentUnit === 'lbs' ? current.totalLbs : current.totalKg;
        const peakValue = peak
          ? currentUnit === 'lbs'
            ? peak.totalLbs
            : peak.totalKg
          : totalValue;
        const squatValue =
          currentUnit === 'lbs'
            ? current.squatE1rm
            : Math.round(current.squatE1rm * 0.453592);
        const benchValue =
          currentUnit === 'lbs'
            ? current.benchE1rm
            : Math.round(current.benchE1rm * 0.453592);
        const deadliftValue =
          currentUnit === 'lbs'
            ? current.deadliftE1rm
            : Math.round(current.deadliftE1rm * 0.453592);

        // Determine club status
        const clubThresholds = [
          {
            threshold: 1500,
            name: '1500 lb Club',
            color: '#ffd700',
            emoji: 'üëë',
          },
          {
            threshold: 1400,
            name: '1400 lb Club',
            color: '#e6b800',
            emoji: 'üëë',
          },
          {
            threshold: 1300,
            name: '1300 lb Club',
            color: '#d4af37',
            emoji: 'üí™',
          },
          {
            threshold: 1200,
            name: '1200 lb Club',
            color: '#c0c0c0',
            emoji: 'üí™',
          },
          {
            threshold: 1100,
            name: '1100 lb Club',
            color: '#b8860b',
            emoji: 'üèÜ',
          },
          {
            threshold: 1000,
            name: '1000 lb Club',
            color: '#cd7f32',
            emoji: 'üèÜ',
          },
          {
            threshold: 750,
            name: '750 lb Club',
            color: '#4a9eff',
            emoji: 'üíé',
          },
          {
            threshold: 500,
            name: '500 lb Club',
            color: '#51cf66',
            emoji: '‚≠ê',
          },
        ];

        const achievedClub = clubThresholds.find(
          (c) => current.totalLbs >= c.threshold,
        );
        const nextClub = clubThresholds
          .slice()
          .reverse()
          .find((c) => current.totalLbs < c.threshold);

        html += `<div class="chart-container">`;
        html += `<h3 class="total-header">
                  ${achievedClub ? achievedClub.emoji : 'üéØ'} Powerlifting Total (S+B+D)
              </h3>`;

        // Current total display
        html += `<div class="lift-stats-grid">`;

        html += `
                  <div>
                      <div class="stat-mini-label">Current Total</div>
                      <div class="stat-mini-value large" style="color: ${achievedClub ? achievedClub.color : '#dadada'};">${Math.round(totalValue)} ${currentUnit}</div>
                      ${achievedClub ? `<div class="stat-mini-detail" style="color: ${achievedClub.color};">${achievedClub.name}</div>` : ''}
                  </div>
                  <div>
                      <div class="stat-mini-label">Squat e1RM</div>
                      <div class="stat-mini-value accent-blue">${Math.round(squatValue)} ${currentUnit}</div>
                  </div>
                  <div>
                      <div class="stat-mini-label">Bench e1RM</div>
                      <div class="stat-mini-value accent-red">${Math.round(benchValue)} ${currentUnit}</div>
                  </div>
                  <div>
                      <div class="stat-mini-label">Deadlift e1RM</div>
                      <div class="stat-mini-value accent-green">${Math.round(deadliftValue)} ${currentUnit}</div>
                  </div>
              </div>`;

        // Club milestones achieved section
        const achievedMilestones = Object.entries(clubs).sort(
          (a, b) => parseInt(b[0]) - parseInt(a[0]),
        );
        if (achievedMilestones.length > 0) {
          html += `<div class="club-milestones"><h4>Club Milestones Achieved</h4>`;

          // Next club progress
          if (nextClub) {
            const remaining = nextClub.threshold - current.totalLbs;
            const progressPercent = (current.totalLbs / nextClub.threshold) * 100;
            html += `
                        <div class="progress-indicator" style="margin-bottom: 1.5rem;">
                            <div class="progress-header">
                                <span class="progress-label">Progress to ${nextClub.name}</span>
                                <span class="progress-value">${Math.round(remaining)} lbs to go</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill accent-blue" style="width: ${Math.min(progressPercent, 100)}%;"></div>
                            </div>
                        </div>
                    `;
          }

          achievedMilestones.forEach(([threshold, data]) => {
            const club = clubThresholds.find(
              (c) => c.threshold === parseInt(threshold),
            );
            if (club && data) {
              html += `
                              <div class="milestone">
                                  <div class="milestone-date">${data.date}</div>
                                  <div class="milestone-text">
                                      <span style="color: ${club.color};">${club.emoji} ${club.name}</span>
                                      <span class="club-milestone-text">(S:${Math.round(data.squat)} B:${Math.round(data.bench)} D:${Math.round(data.deadlift)} = ${Math.round(data.totalLbs)} lbs)</span>
                                  </div>
                              </div>
                          `;
            }
          });
          html += `</div>`;
        }

        // Add volume and workout milestones
        if (milestones && milestones.length > 0) {
          html += `<div class="club-milestones"><h4>Volume & Workout Milestones</h4>`;

          // Calculate next workout milestone (increments of 50)
          const totalWorkouts = trainingData.summary.totalWorkouts;
          const nextWorkoutMilestone = Math.ceil(totalWorkouts / 50) * 50;
          const workoutProgress = (totalWorkouts / nextWorkoutMilestone) * 100;
          const workoutsRemaining = nextWorkoutMilestone - totalWorkouts;

          // Calculate next ton milestone (increments of 1000)
          const totalTons = trainingData.summary.totalTons;
          const nextTonMilestone = Math.ceil(totalTons / 1000) * 1000;
          const tonProgress = (totalTons / nextTonMilestone) * 100;
          const tonsRemaining = nextTonMilestone - totalTons;

          // Show whichever milestone is closer to completion
          if (workoutProgress > tonProgress) {
            html += `
              <div class="progress-indicator" style="margin-bottom: 1.5rem;">
                <div class="progress-header">
                  <span class="progress-label">Progress to ${nextWorkoutMilestone} workouts</span>
                  <span class="progress-value">${workoutsRemaining} to go</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-fill accent-blue" style="width: ${Math.min(workoutProgress, 100)}%;"></div>
                </div>
              </div>
            `;
          } else {
            html += `
              <div class="progress-indicator" style="margin-bottom: 1.5rem;">
                <div class="progress-header">
                  <span class="progress-label">Progress to ${nextTonMilestone.toLocaleString()} tons</span>
                  <span class="progress-value">${Math.round(tonsRemaining).toLocaleString()} to go</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-fill accent-blue" style="width: ${Math.min(tonProgress, 100)}%;"></div>
                </div>
              </div>
            `;
          }

          [...milestones]
            .reverse()
            .slice(0, 10)
            .forEach((m) => {
              html += `
              <div class="milestone">
                <div class="milestone-date">${m.date}</div>
                <div class="milestone-text">${m.icon} ${m.milestone}</div>
              </div>
            `;
            });
          html += `</div>`;
        }

        html += `</div>`;
        return html;
      }

      function renderPlateMilestones() {
        const { plateMilestones } = trainingData;
        if (!plateMilestones || Object.keys(plateMilestones).length === 0)
          return '';

        let html = '';
        const plateLabels = {
          1: '1 Plate (135)',
          2: '2 Plates (225)',
          3: '3 Plates (315)',
          4: '4 Plates (405)',
          5: '5 Plates (495)',
        };

        html += `<div class="chart-container">`;
        html += `<h3>üèÖ Plate Milestones</h3>`;

        html += `<div class="plate-grid">`;

        LIFT_ORDER.forEach((lift) => {
          const config = LIFT_CONFIG[lift];
          const liftData = plateMilestones[lift] || {};
          const maxPlates = Math.max(...Object.keys(liftData).map(Number), 0);

          html += `<div class="lift-card lift-card-${lift}">`;
          html += `<h4>${config.name}</h4>`;

          [1, 2, 3, 4, 5].forEach((plates) => {
            const achieved = liftData[plates];
            const plateWeight =
              currentUnit === 'lbs'
                ? plates * 90 + 45
                : Math.round((plates * 90 + 45) * 0.453592);
            const plateLabel =
              currentUnit === 'lbs'
                ? `${plates} plate${plates > 1 ? 's' : ''} (${plates * 90 + 45})`
                : `${plates} plate${plates > 1 ? 's' : ''} (${plateWeight}kg)`;

            if (achieved) {
              html += `
                              <div class="plate-item">
                                  <span class="plate-icon">‚úÖ</span>
                                  <span class="plate-label">${plateLabel}</span>
                                  <span class="plate-date">${achieved.date}</span>
                              </div>
                          `;
            } else {
              html += `
                              <div class="plate-item unachieved">
                                  <span class="plate-icon">‚¨ú</span>
                                  <span class="plate-label text-muted-color">${plateLabel}</span>
                                  <span class="plate-date">‚Äî</span>
                              </div>
                          `;
            }
          });

          html += `</div>`;
        });

        html += `</div></div>`;
        return html;
      }

      function renderAllTimePRs() {
        const { allTimePRs } = trainingData;
        if (!allTimePRs || Object.keys(allTimePRs).length === 0) return '';

        let html = '';
        html += `<div class="chart-container">`;
        html += `<h3 class="section-title">üèÜ All-Time PRs</h3>`;

        html += `<div class="grid-2col">`;

        LIFT_ORDER.forEach((lift) => {
          const config = LIFT_CONFIG[lift];
          const liftData = allTimePRs[lift];
          if (!liftData) return;

          const maxEver = liftData.maxEver;
          const bestE1rm = liftData.bestE1rm;
          const repPRs = liftData.repPRs || {};

          html += `<div class="lift-card lift-card-${lift}">`;
          html += `<h4>${config.name}</h4>`;

          // Best e1RM
          if (bestE1rm) {
            const e1rmValue =
              currentUnit === 'lbs' ? bestE1rm.e1rmLbs : bestE1rm.e1rmKg;
            html += `
                          <div class="bg-tertiary rounded-md p-lg mb-lg text-center">
                              <div class="text-muted-color text-sm text-upper mb-xs">Best e1RM</div>
                              <div class="text-3xl font-weight-700">${Math.round(e1rmValue)} ${currentUnit}</div>
                          </div>
                      `;
          }

          // Rep PRs table
          const sortedReps = Object.keys(repPRs)
            .map(Number)
            .sort((a, b) => a - b);
          if (sortedReps.length > 0) {
            html += `<div class="text-base">`;
            sortedReps.forEach((reps) => {
              const pr = repPRs[reps];
              const weight = currentUnit === 'lbs' ? pr.weightLbs : pr.weightKg;
              html += `
                              <div class="flex flex-between border-bottom" style="padding: 0.35rem 0;">
                                  <span class="text-muted-color">${reps}RM</span>
                                  <span class="text-primary-color font-weight-600">${Math.round(weight)} ${currentUnit}</span>
                              </div>
                          `;
            });
            html += `</div>`;
          }

          html += `</div>`;
        });

        html += `</div></div>`;
        return html;
      }

      function renderPRTimeline() {
        const container = document.getElementById('prTimeline');
        if (!trainingData.bigThreeE1RM) {
          container.innerHTML = '<p class="text-muted-color">No PR data available</p>';
          return;
        }

        // Only track 3+ plate milestones (skip 135/225)
        const plateMilestones = [315, 405, 495];
        const events = [];
        const lifts = ['squat', 'bench', 'deadlift', 'ohp'];
        const liftNames = { squat: 'Squat', bench: 'Bench', deadlift: 'Deadlift', ohp: 'OHP' };

        lifts.forEach(lift => {
          const liftData = trainingData.bigThreeE1RM[lift];
          if (!liftData?.e1rmHistory?.length) return;

          const history = liftData.e1rmHistory;
          const achieved = new Set();
          let maxE1RM = 0;

          // Find 3+ plate milestones only
          history.forEach(entry => {
            const e1rm = getVolume(entry.e1rmLbs, entry.e1rmKg);
            if (e1rm > maxE1RM) {
              const lbs = Math.round(entry.e1rmLbs);
              plateMilestones.forEach(plate => {
                if (lbs >= plate && !achieved.has(plate)) {
                  events.push({
                    date: new Date(entry.date),
                    lift,
                    liftName: liftNames[lift],
                    e1rmLbs: lbs,
                    e1rmKg: Math.round(entry.e1rmKg),
                    milestone: `${plate} lb`,
                    type: 'plate',
                    plateValue: plate
                  });
                  achieved.add(plate);
                }
              });
              maxE1RM = e1rm;
            }
          });

          // Add peak PR for this lift
          const peak = history.reduce((max, p) =>
            getVolume(p.e1rmLbs, p.e1rmKg) > getVolume(max.e1rmLbs, max.e1rmKg) ? p : max
          );
          events.push({
            date: new Date(peak.date),
            lift,
            liftName: liftNames[lift],
            e1rmLbs: Math.round(peak.e1rmLbs),
            e1rmKg: Math.round(peak.e1rmKg),
            milestone: 'All-Time Best',
            type: 'peak'
          });
        });

        // Add total club milestones (1000lb+)
        const clubs = trainingData.powerliftingTotals?.clubMilestones || {};
        const significantClubs = [1000, 1100, 1200, 1300, 1400, 1500];

        Object.entries(clubs).forEach(([threshold, data]) => {
          const thresholdNum = parseInt(threshold);
          if (significantClubs.includes(thresholdNum) && data) {
            events.push({
              date: new Date(data.date),
              lift: 'total',
              liftName: 'Total',
              e1rmLbs: Math.round(data.totalLbs),
              e1rmKg: Math.round(data.totalLbs * 0.453592),
              milestone: `${thresholdNum} lb Club`,
              type: 'club',
              clubData: data
            });
          }
        });

        if (events.length === 0) {
          container.innerHTML = '<p class="text-muted-color">No significant PR events found</p>';
          return;
        }

        // Sort newest first (descending by date)
        events.sort((a, b) => b.date - a.date);

        // Build clean vertical list HTML
        let html = '<div class="pr-timeline-list">';

        events.forEach(event => {
          const weight = currentUnit === 'lbs' ? event.e1rmLbs : event.e1rmKg;
          const dateStr = event.date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
          });

          // Determine visual elements based on event type
          let icon, typeLabel, cardClass;
          if (event.type === 'peak') {
            icon = '&#9733;'; // Star symbol (‚òÖ)
            typeLabel = 'Peak PR';
            cardClass = 'pr-event-peak';
          } else if (event.type === 'club') {
            icon = '&#127942;'; // Trophy (üèÜ)
            typeLabel = 'Total Club';
            cardClass = 'pr-event-club';
          } else {
            icon = '&#9651;'; // Triangle (‚ñ≥) for plate milestones
            typeLabel = 'Plate Milestone';
            cardClass = 'pr-event-plate';
          }

          // Use lift color for styling, gold for club milestones
          const colorVar = event.lift === 'total'
            ? '--accent-gold'
            : `--lift-${event.lift}`;

          html += `
            <div class="pr-event-card ${cardClass}" style="--event-color: var(${colorVar});">
              <div class="pr-event-indicator">
                <span class="pr-event-icon">${icon}</span>
              </div>
              <div class="pr-event-content">
                <div class="pr-event-header">
                  <span class="pr-event-lift">${event.liftName}</span>
                  <span class="pr-event-type">${typeLabel}</span>
                </div>
                <div class="pr-event-details">
                  <span class="pr-event-milestone">${event.milestone}</span>
                  <span class="pr-event-weight">${weight} ${currentUnit}</span>
                </div>
              </div>
              <div class="pr-event-date">${dateStr}</div>
            </div>
          `;
        });

        html += '</div>';
        container.innerHTML = html;
      }

      function renderPRsAndClubs() {
        const container = document.getElementById('prsClubsContent');

        if (
          !trainingData.powerliftingTotals &&
          !trainingData.plateMilestones &&
          !trainingData.allTimePRs
        ) {
          container.innerHTML =
            '<p class="text-muted-color">No PR data available</p>';
          return;
        }

        let html = '';
        html += renderPowerliftingTotals();
        html += renderPlateMilestones();
        html += renderAllTimePRs();
        container.innerHTML = html;
      }


      function renderDayOfWeekChart() {
        const { workoutsByDayOfWeek } = trainingData;
        const container = document.getElementById('dayOfWeekChart');

        const dayOrder = [
          'Monday',
          'Tuesday',
          'Wednesday',
          'Thursday',
          'Friday',
          'Saturday',
          'Sunday',
        ];
        const data = dayOrder
          .filter((day) => workoutsByDayOfWeek[day])
          .map((day) => ({
            day,
            volume: getVolume(
              workoutsByDayOfWeek[day].avgVolumeLbs,
              workoutsByDayOfWeek[day].avgVolumeKg,
            ),
            count: workoutsByDayOfWeek[day].count,
          }));

        if (data.length === 0) return;

        const width = container.offsetWidth;
        const height = 400;
        const padding = { top: 40, right: 40, bottom: 80, left: 80 };

        const maxVolume = Math.max(...data.map((d) => d.volume));
        const minVolume = Math.min(...data.map((d) => d.volume));
        const barWidth = (width - padding.left - padding.right) / data.length;

        const svg = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'svg',
        );
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        // Define gradient for bars
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', 'barGradient');
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('x2', '0%');
        gradient.setAttribute('y1', '100%');
        gradient.setAttribute('y2', '0%');

        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('style', 'stop-color:#2196F3;stop-opacity:1');

        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('style', 'stop-color:#64B5F6;stop-opacity:1');

        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
        svg.appendChild(defs);

        // Grid lines
        for (let i = 0; i <= 5; i++) {
          const y =
            padding.top + (i / 5) * (height - padding.top - padding.bottom);
          const line = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'line',
          );
          line.setAttribute('x1', padding.left);
          line.setAttribute('y1', y);
          line.setAttribute('x2', width - padding.right);
          line.setAttribute('y2', y);
          line.setAttribute('stroke', '#3a3a3a');
          svg.appendChild(line);
        }

        data.forEach((d, i) => {
          const x = padding.left + i * barWidth;
          const barHeight =
            (d.volume / maxVolume) * (height - padding.top - padding.bottom);
          const y = height - padding.bottom - barHeight;

          // Calculate intensity-based color
          const volumeIntensity = (d.volume - minVolume) / (maxVolume - minVolume);
          const baseColor = d.count < 10 ? 0.4 : 1.0; // Reduced opacity for rare days
          const colorIntensity = Math.max(0.3, volumeIntensity) * baseColor;

          // Create color based on intensity (darker blue for low, brighter for high)
          const r = Math.floor(66 + (100 - 66) * colorIntensity);
          const g = Math.floor(165 + (181 - 165) * colorIntensity);
          const b = Math.floor(245 + (246 - 245) * colorIntensity);
          const fillColor = `rgba(${r}, ${g}, ${b}, ${baseColor})`;

          // Bar with intensity-based coloring
          const rect = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'rect',
          );
          rect.setAttribute('x', x + barWidth * 0.1);
          rect.setAttribute('y', height - padding.bottom); // Start from bottom for animation
          rect.setAttribute('width', barWidth * 0.8);
          rect.setAttribute('height', 0); // Start with 0 height for animation
          rect.setAttribute('fill', d.count < 10 ? '#4a9eff66' : 'url(#barGradient)');
          rect.setAttribute('rx', '4'); // Rounded corners
          rect.setAttribute('ry', '4');

          // Animate bar growth
          const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
          animate.setAttribute('attributeName', 'height');
          animate.setAttribute('from', '0');
          animate.setAttribute('to', barHeight);
          animate.setAttribute('begin', `${i * 0.1}s`);
          animate.setAttribute('dur', '0.6s');
          animate.setAttribute('fill', 'freeze');

          const animateY = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
          animateY.setAttribute('attributeName', 'y');
          animateY.setAttribute('from', height - padding.bottom);
          animateY.setAttribute('to', y);
          animateY.setAttribute('begin', `${i * 0.1}s`);
          animateY.setAttribute('dur', '0.6s');
          animateY.setAttribute('fill', 'freeze');

          rect.appendChild(animate);
          rect.appendChild(animateY);

          // Add hover effect
          rect.addEventListener('mouseenter', (e) => {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.innerHTML = `
                        <strong>${d.day}</strong><br>
                        ${d.count} workout${d.count !== 1 ? 's' : ''}<br>
                        Avg volume: ${Math.round(d.volume).toLocaleString()} ${currentUnit}
                    `;
            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY + 10 + 'px';
          });
          rect.addEventListener('mouseleave', hideTooltip);

          svg.appendChild(rect);

          // Workout count label (above bar)
          const countLabel = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          countLabel.setAttribute('x', x + barWidth / 2);
          countLabel.setAttribute('y', y - 8);
          countLabel.setAttribute('text-anchor', 'middle');
          countLabel.setAttribute('fill', d.count < 10 ? '#666' : '#aaa');
          countLabel.setAttribute('font-size', '11');
          countLabel.setAttribute(
            'font-weight',
            d.count < 10 ? 'normal' : '600',
          );
          countLabel.textContent = `${d.count}√ó`;
          svg.appendChild(countLabel);

          // Day label
          const label = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text',
          );
          label.setAttribute('x', x + barWidth / 2);
          label.setAttribute('y', height - padding.bottom + 20);
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('fill', '#888');
          label.setAttribute('font-size', '12');
          label.textContent = d.day.substring(0, 3);
          svg.appendChild(label);

          // Add note for low-frequency days
          if (d.count < 10) {
            const noteLabel = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'text',
            );
            noteLabel.setAttribute('x', x + barWidth / 2);
            noteLabel.setAttribute('y', height - padding.bottom + 35);
            noteLabel.setAttribute('text-anchor', 'middle');
            noteLabel.setAttribute('fill', '#666');
            noteLabel.setAttribute('font-size', '9');
            noteLabel.textContent = '(rare)';
            svg.appendChild(noteLabel);
          }
        });

        container.innerHTML = '';
        container.appendChild(svg);
      }

      function renderPrograms() {
        const { programs } = trainingData;
        const container = document.getElementById('programsList');

        if (!programs || programs.length === 0) {
          container.innerHTML =
            '<p style="color: var(--text-muted);">No programs found</p>';
          return;
        }

        container.innerHTML = programs
          .map(
            (program) => `
                <div class="program-card">
                    <div class="program-name">${program.name}</div>
                    <div>${program.startDate} ‚Üí ${program.endDate}</div>
                    <div class="program-stats">
                        <span>${program.workouts} workouts</span>
                        <span>${formatVolume(program.totalVolumeLbs, program.totalVolumeKg)} total volume</span>
                        <span style="color: #ffd700;">${program.prsSet || 0} PRs set</span>
                    </div>
                </div>
            `,
          )
          .join('');
      }

      function renderNotableWorkouts() {
        const { notableWorkouts } = trainingData;
        const container = document.getElementById('notableWorkoutsList');

        if (!notableWorkouts || notableWorkouts.length === 0) {
          container.innerHTML =
            '<p style="color: var(--text-muted);">No notable workouts found</p>';
          return;
        }

        // Group by category
        const volumeRecords = notableWorkouts.filter(
          (w) => w.category === 'volume',
        );
        const setRecords = notableWorkouts.filter((w) => w.category === 'sets');
        const comebacks = notableWorkouts.filter(
          (w) => w.category === 'comeback',
        );

        let html = '';

        // Volume Records
        if (volumeRecords.length > 0) {
          html += '<h3 class="mb-md">üèÜ Volume Records</h3>';
          volumeRecords.forEach((workout) => {
            html += `
              <div class="notable-workout">
                <div class="notable-date">${workout.date}</div>
                <div class="font-weight-600">${workout.reason}</div>
                <div class="text-muted-color mt-xs">
                  ${formatVolume(workout.volumeLbs, workout.volumeKg)} ‚Ä¢ ${workout.details}
                </div>
              </div>
            `;
          });
        }

        // Set Records
        if (setRecords.length > 0) {
          html += '<h3 class="mt-xl mb-md">üí™ Set Records</h3>';
          setRecords.forEach((workout) => {
            html += `
              <div class="notable-workout" style="border-left-color: #51cf66;">
                <div class="notable-date">${workout.date}</div>
                <div class="font-weight-600">${workout.reason}</div>
                <div class="text-muted-color mt-xs">
                  ${formatVolume(workout.volumeLbs, workout.volumeKg)} ‚Ä¢ ${workout.details}
                </div>
              </div>
            `;
          });
        }

        // Comebacks
        if (comebacks.length > 0) {
          html += '<h3 class="mt-xl mb-md">üî• Comeback Workouts</h3>';
          comebacks.forEach((workout) => {
            html += `
              <div class="notable-workout" style="border-left-color: #ffd93d;">
                <div class="notable-date">${workout.date}</div>
                <div class="font-weight-600">${workout.reason}</div>
                <div class="text-muted-color mt-xs">
                  ${formatVolume(workout.volumeLbs, workout.volumeKg)} ‚Ä¢ ${workout.details}
                </div>
              </div>
            `;
          });
        }

        container.innerHTML = html;
      }

      // Scroll spy for navigation
      function updateActiveNav() {
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('nav a');

        let current = '';
        sections.forEach((section) => {
          const sectionTop = section.offsetTop;
          const sectionHeight = section.clientHeight;
          if (window.scrollY >= sectionTop - 100) {
            current = section.getAttribute('id');
          }
        });

        navLinks.forEach((link) => {
          link.classList.remove('active');
          if (link.getAttribute('href') === `#${current}`) {
            link.classList.add('active');
          }
        });
      }

      // Add shadow to nav when scrolled
      function updateNavShadow() {
        const nav = document.getElementById('mainNav');
        if (window.scrollY > 0) {
          nav.classList.add('scrolled');
        } else {
          nav.classList.remove('scrolled');
        }
      }

      window.addEventListener('scroll', () => {
        updateActiveNav();
        updateNavShadow();
      });
      window.addEventListener('load', () => {
        updateActiveNav();
        updateNavShadow();
      });

      // Initialize on page load
      init();
    </script>
  </body>
</html>
